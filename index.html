<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Reroll Challenge</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"/>
  <style>
    :root {
      --primary: #2c3e50;
      --secondary: #3498db;
      --accent: #e74c3c;
      --light: #ecf0f1;
      --dark: #2c3e50;
      --success: #2ecc71;
      --warning: #f39c12;
      --purple: #9b59b6;
      --gray: #95a5a6;
    }

    * { box-sizing: border-box; margin: 0; padding: 0; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
    body { background-color: #f5f7fa; color: var(--dark); line-height: 1.6; }
    .container { max-width: 1400px; margin: 0 auto; padding: 20px; }

    header {
      background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
      color: white; padding: 25px; border-radius: 12px; margin-bottom: 25px; text-align: center;
      box-shadow: 0 6px 12px rgba(0,0,0,0.15);
    }
    h1 { margin-bottom: 10px; font-size: 2.5rem; }
    .subtitle { font-style: italic; opacity: 0.9; font-size: 1.1rem; }

    .tabs {
      display: flex; margin-bottom: 20px; background: white; border-radius: 12px; overflow: hidden;
      box-shadow: 0 4px 10px rgba(0,0,0,0.1);
    }
    .tab {
      padding: 15px 20px; cursor: pointer; font-weight: 500; transition: background-color 0.2s; flex: 1; text-align: center;
    }
    .tab:not(.active):hover { background-color: #f8f9fa; }
    .tab.active { background-color: var(--secondary); color: white; }
    .tab-content { display: none; }
    .tab-content.active { display: block; }

    .dashboard { display: grid; grid-template-columns: 1fr 350px; gap: 25px; }
    .games-container { background: white; border-radius: 12px; box-shadow: 0 4px 10px rgba(0,0,0,0.1); padding: 25px; }
    .section-header {
      display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; padding-bottom: 15px; border-bottom: 2px solid var(--light);
    }
    .game-list { display: flex; flex-direction: column; gap: 20px; }
    .game-card {
      border: 1px solid #e0e0e0; border-radius: 10px; padding: 20px; background: white; transition: transform 0.2s, box-shadow 0.2s; position: relative;
    }
    .game-card:hover { transform: translateY(-5px); box-shadow: 0 8px 16px rgba(0,0,0,0.1); }
    .game-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; }
    .game-title { font-weight: bold; font-size: 1.1em; color: var(--primary); display: flex; align-items: center; gap: 10px; }
    .game-title select { padding: 6px 8px; border-radius: 6px; border: 1px solid #ddd; }
    .game-progress { font-size: 0.95em; color: #666; display: flex; gap: 15px; }

    .game-details { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 15px; }
    .handicap-section strong { display: block; margin-bottom: 6px; }
    .handicap {
      background: #f8f9fa; padding: 10px; border-radius: 6px; font-size: 0.9em; margin-bottom: 8px;
      display: flex; justify-content: space-between; align-items: center;
    }
    .handicap.permanent { border-left: 4px solid var(--accent); }
    .handicap.temporary { border-left: 4px solid var(--secondary); }
    .handicap-actions { display: flex; gap: 8px; }
    .handicap-btn { background: none; border: none; cursor: pointer; font-size: 0.9em; color: var(--gray); }
    .handicap-btn:hover { color: var(--accent); }

    .timer-widget {
      display: flex; align-items: center; gap: 10px; margin-top: 10px; padding: 10px; background: #f8f9fa; border-radius: 6px;
    }
    .timer-display { font-family: monospace; font-size: 1.2em; font-weight: bold; }
    .timer-btn { padding: 6px 10px; font-size: 0.9em; }

    .controls { display: flex; gap: 12px; margin-top: 15px; flex-wrap: wrap; }
    button {
      padding: 10px 15px; border: none; border-radius: 6px; cursor: pointer; font-weight: 500; transition: all 0.2s;
      display: inline-flex; align-items: center; gap: 6px;
    }
    .btn-primary { background-color: var(--secondary); color: white; }
    .btn-primary:hover { background-color: #2980b9; transform: translateY(-2px); }
    .btn-danger { background-color: var(--accent); color: white; }
    .btn-danger:hover { background-color: #c0392b; transform: translateY(-2px); }
    .btn-success { background-color: var(--success); color: white; }
    .btn-success:hover { background-color: #27ae60; transform: translateY(-2px); }
    .btn-warning { background-color: var(--warning); color: white; }
    .btn-warning:hover { background-color: #e67e22; transform: translateY(-2px); }
    .btn-purple { background-color: var(--purple); color: white; }
    .btn-purple:hover { background-color: #8e44ad; transform: translateY(-2px); }
    .btn-gray { background-color: #bdc3c7; color: white; cursor: not-allowed; }

    .sidebar { display: flex; flex-direction: column; gap: 25px; }
    .panel { background: white; border-radius: 12px; box-shadow: 0 4px 10px rgba(0,0,0,0.1); padding: 20px; }
    .panel h3 { margin-bottom: 15px; padding-bottom: 10px; border-bottom: 2px solid var(--light); color: var(--primary); }

    .action-buttons { display: flex; flex-direction: column; gap: 12px; }
    .action-button { width: 100%; text-align: left; padding: 12px; justify-content: flex-start; }

    .stats { background: #f8f9fa; padding: 15px; border-radius: 8px; }
    .stat-item {
      display: flex; justify-content: space-between; margin-bottom: 10px; padding-bottom: 8px; border-bottom: 1px solid #e0e0e0;
    }
    .stat-item:last-child { border-bottom: none; margin-bottom: 0; padding-bottom: 0; }

    .token-counter {
      display: flex; align-items: center; justify-content: center; gap: 10px; font-size: 1.2em; margin: 15px 0;
    }
    .token-icon { color: var(--warning); font-size: 1.5em; }
    .token-value { font-weight: bold; font-size: 1.3em; }

    footer {
      text-align: center; margin-top: 40px; padding: 25px; color: #7f8c8d; font-size: 0.95em; background: white; border-radius: 12px;
      box-shadow: 0 4px 10px rgba(0,0,0,0.1);
    }

    .database-list { max-height: 500px; overflow-y: auto; }
    .database-game { margin-bottom: 20px; padding-bottom: 15px; border-bottom: 1px solid #eee; }
    .database-game:last-child { border-bottom: none; }
    .handicap-list { margin-left: 20px; }
    .db-handicap { background: #f8f9fa; padding: 8px 10px; border-radius: 6px; margin: 6px 0; }
    .db-handicap.permanent { border-left: 4px solid var(--accent); }
    .db-handicap.temporary { border-left: 4px solid var(--secondary); }

    .modal {
      display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background-color: rgba(0,0,0,0.5); z-index: 1000; justify-content: center; align-items: center;
    }
    .modal-content {
      background: white; padding: 30px; border-radius: 12px; width: 90%; max-width: 700px; max-height: 80vh; overflow-y: auto;
      box-shadow: 0 10px 25px rgba(0,0,0,0.2);
    }
    .modal-header {
      display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; padding-bottom: 15px; border-bottom: 2px solid var(--light);
    }
    .close { font-size: 1.8em; cursor: pointer; color: var(--gray); }
    .close:hover { color: var(--dark); }

    .form-group { margin-bottom: 16px; }
    .form-group label { display: block; margin-bottom: 8px; font-weight: 500; }
    .form-group input, .form-group select, .form-group textarea {
      width: 100%; padding: 12px; border: 1px solid #ddd; border-radius: 6px; font-size: 1em;
    }
    .form-actions { display: flex; justify-content: flex-end; gap: 10px; margin-top: 20px; }

    @media (max-width: 992px) {
      .dashboard { grid-template-columns: 1fr; }
      .game-details { grid-template-columns: 1fr; }
    }
    @media (max-width: 576px) {
      .game-header { flex-direction: column; align-items: flex-start; gap: 10px; }
      .controls { flex-direction: column; }
      .controls button { width: 100%; }
      .tabs { flex-direction: column; }
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1><i class="fas fa-dice"></i> Reroll Challenge</h1>
      <p class="subtitle">Rotate through games with increasing challenges.</p>
    </header>

    <div class="tabs">
      <div class="tab active" data-tab="challenge">Challenge</div>
      <div class="tab" data-tab="database">Handicap Database</div>
      <div class="tab" data-tab="rules">Rules</div>
    </div>

    <div class="tab-content active" id="challenge-tab">
      <div class="dashboard">
        <div class="games-container">
          <div class="section-header">
            <h2>Your Rotation</h2>
            <div>
              <button class="btn-primary" onclick="addSlot()">
                <i class="fas fa-plus"></i> Add Slot
              </button>
              <button class="btn-danger" onclick="removeSlot()">
                <i class="fas fa-minus"></i> Remove Slot
              </button>
            </div>
          </div>
          <div class="game-list" id="gameList"></div>
        </div>

        <div class="sidebar">
          <div class="panel">
            <h3>Challenge actions</h3>
            <div class="action-buttons">
              <button class="action-button btn-primary" onclick="rollTempHandicap()">
                <i class="fas fa-random"></i> Roll Temporary Handicap
              </button>
              <button class="action-button btn-primary" onclick="rollPermHandicap()">
                <i class="fas fa-random"></i> Roll Permanent Handicap
              </button>
              <button class="action-button btn-success" onclick="completeRotation()">
                <i class="fas fa-flag-checkered"></i> Complete Rotation
              </button>
              <button class="action-button btn-warning" onclick="rollAchievement()">
                <i class="fas fa-trophy"></i> Roll for Achievement Token
              </button>
              <button class="action-button btn-purple" onclick="useToken()" id="useTokenBtn">
                <i class="fas fa-coins"></i> Use Token to Clear Handicap
              </button>
              <button class="action-button btn-danger" onclick="showResetModal()">
                <i class="fas fa-trash-alt"></i> Reset Progress
              </button>
            </div>
          </div>

          <div class="panel">
            <h3>Game stats</h3>
            <div class="stats">
              <div class="stat-item">
                <span>Total Games:</span>
                <span id="totalGames">0</span>
              </div>
              <div class="stat-item">
                <span>Completed:</span>
                <span id="completedGames">0</span>
              </div>
              <div class="stat-item">
                <span>Active Handicaps:</span>
                <span id="activeHandicaps">0</span>
              </div>
              <div class="stat-item">
                <span>Total Deaths:</span>
                <span id="totalDeaths">0</span>
              </div>
              <div class="stat-item">
                <span>Rotations Completed:</span>
                <span id="rotationsCompleted">0</span>
              </div>
            </div>

            <div class="token-counter">
              <i class="fas fa-coins token-icon"></i>
              <span>Tokens:</span>
              <span class="token-value" id="tokenCount">0</span>
            </div>
          </div>

          <div class="panel">
            <h3>Data management</h3>
            <div class="action-buttons">
              <button class="action-button btn-primary" onclick="showExportModal()">
                <i class="fas fa-file-export"></i> Export Seed
              </button>
              <button class="action-button btn-primary" onclick="showImportModal()">
                <i class="fas fa-file-import"></i> Import Seed
              </button>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="tab-content" id="database-tab">
      <div class="panel">
        <div class="section-header">
          <h2>Handicap database</h2>
          <button class="btn-primary" onclick="showAddHandicapModal()">
            <i class="fas fa-plus"></i> Add to Database
          </button>
        </div>
        <div class="database-list" id="databaseList"></div>
      </div>
    </div>

    <div class="tab-content" id="rules-tab">
      <div class="panel">
        <h2>Reroll Challenge rules</h2>

        <h3>Concept</h3>
        <p>The Reroll Challenge helps you work through your game library by rotating through multiple games with escalating constraints. It’s built for endurance, not speed. Play cleanly, manage risk, and keep momentum.</p>

        <h3>Rotation and sessions</h3>
        <ul class="rules-list">
          <li>Set up 3–10 slots. Each slot is one game in your rotation order.</li>
          <li>Each session is 1 hour per slot, tracked with the slot’s timer widget.</li>
          <li>You progress through slots in order; when the final slot finishes, the rotation ends.</li>
        </ul>

        <h3>Deaths and temporary handicaps</h3>
        <ul class="rules-list">
          <li>When you die in a slot, you immediately switch to the next slot.</li>
          <li>That death also triggers a temporary handicap assigned to a future slot within the same rotation (only to slots appearing after the current slot; Slot 1 is inherently immune to temps caused in prior rotations since temps clear at rotation end).</li>
          <li>Temporary handicaps last one session and clear automatically at the end of the rotation.</li>
        </ul>

        <h3>Permanent handicaps</h3>
        <ul class="rules-list">
          <li>Permanent handicaps are game-specific constraints that persist across rotations.</li>
          <li>Each game can have at most 3 permanent handicaps to avoid softlocks.</li>
          <li>Rolling a permanent handicap selects from that game’s database pool, avoiding duplicates.</li>
        </ul>

        <h3>Tokens and achievements</h3>
        <ul class="rules-list">
          <li>Every achievement you earn (any game) has a 20% chance to grant a token.</li>
          <li>Tokens can clear one permanent handicap. You may use at most one token per rotation.</li>
        </ul>

        <h3>Rotation end</h3>
        <ul class="rules-list">
          <li>Completing the final slot clears all temporary handicaps.</li>
          <li>There’s a 1% chance at rotation end to also clear all permanent handicaps.</li>
          <li>Rotations completed increments; token usage resets.</li>
        </ul>

        <h3>Database and slots</h3>
        <ul class="rules-list">
          <li>Maintain a database of games with separate pools for permanent and temporary handicaps.</li>
          <li>Each slot selects a game from the database via a dropdown.</li>
          <li>All handicap rolls reference the selected game’s database pools.</li>
        </ul>

        <h3>Reset behavior</h3>
        <ul class="rules-list">
          <li>Reset Progress clears deaths, timers, temporary handicaps, permanent handicaps attached to slots, token usage in rotation, tokens, and rotations count.</li>
          <li>Reset does not remove slots, selected games, or the database itself.</li>
        </ul>

        <h3>Goal</h3>
        <p>Clear all games in the fewest rotations possible. Fewer deaths, smarter plays, faster clears.</p>
      </div>
    </div>

    <footer>
      <p>Reroll Challenge v1.2 — Share with friends and challenge yourselves!</p>
    </footer>
  </div>

  <!-- Add Handicap Modal -->
  <div class="modal" id="addHandicapModal">
    <div class="modal-content">
      <div class="modal-header">
        <h2>Add to database</h2>
        <span class="close" onclick="closeModal('addHandicapModal')">&times;</span>
      </div>
      <div class="form-group">
        <label for="dbGameName">Game</label>
        <div style="display:flex; gap:10px;">
          <select id="dbGameSelect" style="flex:1"></select>
          <input id="dbGameName" placeholder="Or type a new game" style="flex:1"/>
        </div>
      </div>
      <div class="form-group">
        <label for="handicapType">Handicap type</label>
        <select id="handicapType">
          <option value="permanent">Permanent</option>
          <option value="temporary">Temporary</option>
        </select>
      </div>
      <div class="form-group">
        <label for="handicapName">Handicap name</label>
        <input id="handicapName" placeholder="Enter handicap name"/>
      </div>
      <div class="form-group">
        <label for="handicapDescription">Description (optional)</label>
        <textarea id="handicapDescription" placeholder="Enter description"></textarea>
      </div>
      <div class="form-actions">
        <button class="btn-danger" onclick="closeModal('addHandicapModal')">Cancel</button>
        <button class="btn-success" onclick="addNewHandicap()">Add</button>
      </div>
    </div>
  </div>

  <!-- Reset Modal -->
  <div class="modal" id="resetModal">
    <div class="modal-content">
      <div class="modal-header">
        <h2>Reset progress</h2>
        <span class="close" onclick="closeModal('resetModal')">&times;</span>
      </div>
      <p>This will clear deaths, timers, slot-attached handicaps, tokens, and rotation counts — but will not remove slots, selected games, or the database.</p>
      <div class="form-actions">
        <button class="btn-primary" onclick="closeModal('resetModal')">Cancel</button>
        <button class="btn-danger" onclick="resetProgress()">Reset Progress</button>
      </div>
    </div>
  </div>

  <!-- Export Modal -->
  <div class="modal" id="exportModal">
    <div class="modal-content">
      <div class="modal-header">
        <h2>Export seed</h2>
        <span class="close" onclick="closeModal('exportModal')">&times;</span>
      </div>
      <p>Copy the seed below to save your entire challenge state (slots, timers, handicaps, database, tokens, etc.).</p>
      <div class="form-group">
        <textarea id="exportData" rows="8" readonly style="width:100%; font-family:monospace;"></textarea>
      </div>
      <div class="form-actions">
        <button class="btn-primary" onclick="copyExportData()"><i class="fas fa-copy"></i> Copy</button>
        <button class="btn-danger" onclick="closeModal('exportModal')">Close</button>
      </div>
    </div>
  </div>

  <!-- Import Modal -->
  <div class="modal" id="importModal">
    <div class="modal-content">
      <div class="modal-header">
        <h2>Import seed</h2>
        <span class="close" onclick="closeModal('importModal')">&times;</span>
      </div>
      <p>Paste a previously exported seed to restore everything.</p>
      <div class="form-group">
        <textarea id="importData" rows="8" style="width:100%; font-family:monospace;" placeholder="Paste seed here"></textarea>
      </div>
      <div class="form-actions">
        <button class="btn-success" onclick="importChallengeData()"><i class="fas fa-file-import"></i> Import</button>
        <button class="btn-danger" onclick="closeModal('importModal')">Cancel</button>
      </div>
    </div>
  </div>

  <!-- Result Modal -->
  <div class="modal" id="resultModal">
    <div class="modal-content">
      <div class="modal-header">
        <h2 id="resultTitle">Result</h2>
        <span class="close" onclick="closeModal('resultModal')">&times;</span>
      </div>
      <div id="resultContent"></div>
    </div>
  </div>

  <script>
    // Core data
    let challengeData = {
      slots: [],
      rotationsCompleted: 0,
      tokens: 0,
      tokenUsedThisRotation: false,
      gameDatabase: [],
      permHandicaps: {},
      tempHandicaps: {}
    };

    // Sample seeds for first run
    const sampleGames = [
      "Vampire: The Masquerade – Bloodlines",
      "Enderal",
      "Amazing Cultivation Simulator",
      "Fallout 76",
      "Age of Decadence"
    ];
    const samplePermHandicaps = {
      "Vampire: The Masquerade – Bloodlines": [
        "Clan Loyalty - Must pick one Discipline and always prioritize it when spending XP",
        "No Easy Meal - Must avoid feeding on innocents; only feed on criminals, enemies, or blood packs"
      ],
      "Enderal": [
        "Ascetic Path - No food/drink buffs",
        "Class Purist - Stick to one archetype tree"
      ],
      "Amazing Cultivation Simulator": [
        "No Outer Sect - Cannot recruit or interact with any outer sects for the rest of the run",
        "One Life - If a disciple dies, the run ends"
      ],
      "Fallout 76": [
        "Scavenger Only - No vendor purchases",
        "Pacifist Trades - No PvP engagements"
      ],
      "Age of Decadence": [
        "No Save Scum - One try per check",
        "Faction Loyalist - Commit to first faction choice"
      ]
    };
    const sampleTempHandicaps = {
      "Vampire: The Masquerade – Bloodlines": [
        "Hunger Unchecked - Cannot feed until the end of the current questline",
        "Beast's Restraint - No blood disciplines in one major dungeon"
      ],
      "Enderal": [
        "The Long Night - Travel only by night",
        "Blind Pilgrim - No map use for one major journey"
      ],
      "Amazing Cultivation Simulator": [
        "One Disciple Sect - Limit recruitment to one disciple for this session",
        "Manual Labor Only - No automation this session"
      ],
      "Fallout 76": [
        "Iron Stomach - No food buffs this session",
        "Barebones - No Power Armor this session"
      ],
      "Age of Decadence": [
        "No Merchants - Use only looted gear this session",
        "Silent Tongue - No persuasion checks this session"
      ]
    };

    // Init
    function init() {
      const saved = localStorage.getItem('rerollChallengeData');
      if (saved) {
        try {
          challengeData = JSON.parse(saved);
          // Clean up timer intervals if any persisted incorrectly
          challengeData.slots.forEach(s => { s.timerInterval = null; s.timerActive = false; });
        } catch {
          loadSample();
        }
      } else {
        loadSample();
      }
      ensureAtLeastThreeSlots();

      renderGames();
      updateStats();
      updateTokenButton();
      renderDatabase();
      setupTabs();
    }

    function loadSample() {
      challengeData = {
        slots: [],
        rotationsCompleted: 0,
        tokens: 0,
        tokenUsedThisRotation: false,
        gameDatabase: [...sampleGames],
        permHandicaps: JSON.parse(JSON.stringify(samplePermHandicaps)),
        tempHandicaps: JSON.parse(JSON.stringify(sampleTempHandicaps))
      };
    }

    function ensureAtLeastThreeSlots() {
      while (challengeData.slots.length < 3) {
        challengeData.slots.push(newSlot(challengeData.slots.length + 1));
      }
    }

    function newSlot(id) {
      return {
        id,
        game: "",
        progress: "Not Started",
        deaths: 0,
        permanentHandicaps: [],
        temporaryHandicaps: [],
        timer: 0,
        timerActive: false,
        timerInterval: null
      };
    }

    function saveData() {
      localStorage.setItem('rerollChallengeData', JSON.stringify(challengeData));
    }

    // Tabs
    function setupTabs() {
      document.querySelectorAll('.tab').forEach(tab => {
        tab.addEventListener('click', () => {
          const name = tab.getAttribute('data-tab');
          document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
          document.querySelectorAll('.tab-content').forEach(tc => tc.classList.remove('active'));
          tab.classList.add('active');
          document.getElementById(`${name}-tab`).classList.add('active');
        });
      });
    }

    // Render challenge slots
    function renderGames() {
      const gameList = document.getElementById('gameList');
      gameList.innerHTML = '';

      challengeData.slots.forEach(slot => {
        const card = document.createElement('div');
        card.className = 'game-card';

        const timerMinutes = Math.floor(slot.timer / 60);
        const timerSeconds = slot.timer % 60;
        const timerDisplay = `${timerMinutes.toString().padStart(2, '0')}:${timerSeconds.toString().padStart(2, '0')}`;

        card.innerHTML = `
          <div class="game-header">
            <div class="game-title">
              <span>Slot ${slot.id}</span>
              <select onchange="updateGame(${slot.id}, this.value)">
                <option value="">-- Select a game --</option>
                ${challengeData.gameDatabase.map(g =>
                  `<option value="${escapeHtml(g)}"${slot.game === g ? ' selected' : ''}>${escapeHtml(g)}</option>`
                ).join('')}
              </select>
            </div>
            <div class="game-progress">
              <span>${slot.progress} | Deaths: ${slot.deaths}</span>
            </div>
          </div>

          ${slot.game ? `
            <div class="game-details">
              <div class="handicap-section">
                <strong>Permanent Handicaps</strong>
                ${slot.permanentHandicaps.length > 0 ?
                  slot.permanentHandicaps.map(h => `
                    <div class="handicap permanent">
                      <span>${escapeHtml(h)}</span>
                      <div class="handicap-actions">
                        <button class="handicap-btn" title="Remove" onclick="clearSpecificHandicap(${slot.id}, 'permanent', '${escapeAttr(h)}')">
                          <i class="fas fa-times"></i>
                        </button>
                      </div>
                    </div>
                  `).join('') : `<div class="handicap">None</div>`
                }
              </div>
              <div class="handicap-section">
                <strong>Temporary Handicaps</strong>
                ${slot.temporaryHandicaps.length > 0 ?
                  slot.temporaryHandicaps.map(h => `
                    <div class="handicap temporary">
                      <span>${escapeHtml(h)}</span>
                      <div class="handicap-actions">
                        <button class="handicap-btn" title="Remove" onclick="clearSpecificHandicap(${slot.id}, 'temporary', '${escapeAttr(h)}')">
                          <i class="fas fa-times"></i>
                        </button>
                      </div>
                    </div>
                  `).join('') : `<div class="handicap">None</div>`
                }
              </div>
            </div>

            <div class="timer-widget">
              <div class="timer-display">${timerDisplay}</div>
              <button class="timer-btn btn-success" ${slot.timerActive ? 'disabled' : ''} onclick="startTimer(${slot.id})">
                <i class="fas fa-play"></i> Start
              </button>
              <button class="timer-btn btn-warning" ${!slot.timerActive ? 'disabled' : ''} onclick="pauseTimer(${slot.id})">
                <i class="fas fa-pause"></i> Pause
              </button>
              <button class="timer-btn btn-danger" onclick="resetTimer(${slot.id})">
                <i class="fas fa-redo"></i> Reset
              </button>
            </div>

            <div class="controls">
              <button class="btn-primary" onclick="addDeath(${slot.id})">
                <i class="fas fa-skull"></i> Add Death
              </button>
              <button class="btn-success" onclick="markComplete(${slot.id})">
                <i class="fas fa-check"></i> Mark Complete
              </button>
            </div>
          ` : `
            <div class="handicap">Select a game from the dropdown to begin.</div>
          `}
        `;

        gameList.appendChild(card);
      });

      updateStats();
      saveData();
    }

    // Stats
    function updateStats() {
      const completed = challengeData.slots.filter(s => s.progress === 'Completed').length;
      const activeHandicaps = challengeData.slots.reduce((t, s) => t + s.permanentHandicaps.length + s.temporaryHandicaps.length, 0);
      const totalDeaths = challengeData.slots.reduce((t, s) => t + s.deaths, 0);
      const totalGames = challengeData.slots.filter(s => !!s.game).length;

      document.getElementById('totalGames').textContent = totalGames;
      document.getElementById('completedGames').textContent = completed;
      document.getElementById('activeHandicaps').textContent = activeHandicaps;
      document.getElementById('totalDeaths').textContent = totalDeaths;
      document.getElementById('rotationsCompleted').textContent = challengeData.rotationsCompleted;
      document.getElementById('tokenCount').textContent = challengeData.tokens;
    }

    // Token button
    function updateTokenButton() {
      const btn = document.getElementById('useTokenBtn');
      if (challengeData.tokens > 0 && !challengeData.tokenUsedThisRotation) {
        btn.disabled = false;
        btn.classList.remove('btn-gray');
        btn.classList.add('btn-purple');
      } else {
        btn.disabled = true;
        btn.classList.remove('btn-purple');
        btn.classList.add('btn-gray');
      }
    }

    // Slot mgmt
    function addSlot() {
      if (challengeData.slots.length >= 10) {
        showResult('Maximum Slots', 'You can only have up to 10 slots.');
        return;
      }
      const id = challengeData.slots.length + 1;
      challengeData.slots.push(newSlot(id));
      renderGames();
      showResult('Slot Added', 'Added a new slot to your rotation.');
    }

    function removeSlot() {
      if (challengeData.slots.length <= 3) {
        showResult('Minimum Slots', 'You must have at least 3 slots.');
        return;
      }
      const removed = challengeData.slots.pop();
      // Stop timer if running
      if (removed.timerInterval) clearInterval(removed.timerInterval);
      renderGames();
      showResult('Slot Removed', 'Removed the last slot from your rotation.');
    }

    function updateGame(slotId, gameName) {
      const slot = challengeData.slots.find(s => s.id === slotId);
      if (!slot) return;

      slot.game = gameName || "";
      if (slot.game) {
        // ensure in database
        if (!challengeData.gameDatabase.includes(slot.game)) {
          challengeData.gameDatabase.push(slot.game);
        }
        if (!challengeData.permHandicaps[slot.game]) challengeData.permHandicaps[slot.game] = [];
        if (!challengeData.tempHandicaps[slot.game]) challengeData.tempHandicaps[slot.game] = [];
      }

      renderGames();
      renderDatabase();
      saveData();
    }

    // Deaths
    function addDeath(slotId) {
      const slot = challengeData.slots.find(s => s.id === slotId);
      if (!slot || !slot.game) {
        showResult('No Game Selected', 'Please select a game for this slot before adding deaths.');
        return;
      }

      slot.deaths++;
      // Assign temp handicap to a future slot with a game
      const futureSlots = challengeData.slots.filter(s => s.id > slotId && s.game);
      if (futureSlots.length > 0) {
        const target = futureSlots[Math.floor(Math.random() * futureSlots.length)];
        const pool = challengeData.tempHandicaps[target.game] || [];
        if (pool.length > 0) {
          const randomHandicap = pool[Math.floor(Math.random() * pool.length)];
          target.temporaryHandicaps.push(randomHandicap);
          renderGames();
          showResult('Death Added', `Added a death to ${escapeHtml(slot.game)}.<br>Temporary handicap added to ${escapeHtml(target.game)}:<br><strong>${escapeHtml(randomHandicap)}</strong>`);
          return;
        }
      }
      renderGames();
      showResult('Death Added', `Added a death to ${escapeHtml(slot.game)}.<br>No valid future slot or no temp handicaps in the target game pool.`);
    }

    function markComplete(slotId) {
      const slot = challengeData.slots.find(s => s.id === slotId);
      if (!slot) return;
      slot.progress = 'Completed';
      renderGames();
      showResult('Game Completed', `Congratulations! You've completed ${escapeHtml(slot.game || 'this slot')}.`);
    }

    function clearSpecificHandicap(slotId, type, handicap) {
      const slot = challengeData.slots.find(s => s.id === slotId);
      if (!slot) return;
      if (type === 'permanent') {
        slot.permanentHandicaps = slot.permanentHandicaps.filter(h => h !== handicap);
      } else {
        slot.temporaryHandicaps = slot.temporaryHandicaps.filter(h => h !== handicap);
      }
      renderGames();
      showResult('Handicap Removed', `Removed ${escapeHtml(type)} handicap from ${escapeHtml(slot.game || 'slot')}:<br><strong>${escapeHtml(handicap)}</strong>`);
    }

    // Rolls
    function rollTempHandicap() {
      // any slot with a game and not completed
      const eligible = challengeData.slots.filter(s => s.game && s.progress !== 'Completed');
      if (eligible.length === 0) {
        showResult('No Eligible Slots', 'No eligible slots found for temporary handicaps.');
        return;
      }
      const slot = eligible[Math.floor(Math.random() * eligible.length)];
      const pool = challengeData.tempHandicaps[slot.game] || [];
      if (pool.length === 0) {
        showResult('No Handicaps', `No temporary handicaps found for ${escapeHtml(slot.game)}.`);
        return;
      }
      const pick = pool[Math.floor(Math.random() * pool.length)];
      slot.temporaryHandicaps.push(pick);
      renderGames();
      showResult('Temporary Handicap', `Added to ${escapeHtml(slot.game)}:<br><strong>${escapeHtml(pick)}</strong>`);
    }

    function rollPermHandicap() {
      const eligible = challengeData.slots.filter(s => s.game && s.progress !== 'Completed');
      if (eligible.length === 0) {
        showResult('No Eligible Slots', 'No eligible slots found for permanent handicaps.');
        return;
      }
      const slot = eligible[Math.floor(Math.random() * eligible.length)];
      if (slot.permanentHandicaps.length >= 3) {
        showResult('Max Handicaps', `${escapeHtml(slot.game)} already has the maximum of 3 permanent handicaps.`);
        return;
      }
      const pool = challengeData.permHandicaps[slot.game] || [];
      if (pool.length === 0) {
        showResult('No Handicaps', `No permanent handicaps found for ${escapeHtml(slot.game)}.`);
        return;
      }
      const available = pool.filter(h => !slot.permanentHandicaps.includes(h));
      if (available.length === 0) {
        showResult('All Applied', `All available permanent handicaps have already been applied to ${escapeHtml(slot.game)}.`);
        return;
      }
      const pick = available[Math.floor(Math.random() * available.length)];
      slot.permanentHandicaps.push(pick);
      renderGames();
      showResult('Permanent Handicap', `Added to ${escapeHtml(slot.game)}:<br><strong>${escapeHtml(pick)}</strong>`);
    }

    function completeRotation() {
      let clearedAll = false;
      // 1% chance to clear permanent handicaps
      if (Math.random() < 0.01) {
        challengeData.slots.forEach(s => s.permanentHandicaps = []);
        clearedAll = true;
      }
      // Clear temps, reset token usage, increment rotations
      challengeData.slots.forEach(s => s.temporaryHandicaps = []);
      challengeData.rotationsCompleted++;
      challengeData.tokenUsedThisRotation = false;

      // Stop timers
      challengeData.slots.forEach(s => { if (s.timerInterval) clearInterval(s.timerInterval); s.timerActive = false; });
      renderGames();
      updateTokenButton();

      if (clearedAll) {
        showResult('Rotation Complete — Lucky!', 'All temporary handicaps cleared.<br>You got lucky and cleared all permanent handicaps too!');
      } else {
        showResult('Rotation Complete', 'All temporary handicaps have been cleared. Ready for next rotation!');
      }
    }

    function rollAchievement() {
      if (Math.random() < 0.2) {
        challengeData.tokens++;
        renderGames();
        updateTokenButton();
        showResult('Token Awarded!', 'Congratulations! You earned a token.<br>You can use it to clear one permanent handicap (max once per rotation).');
      } else {
        showResult('No Token', 'No token awarded this time. Keep going!');
      }
    }

    function useToken() {
      if (challengeData.tokens <= 0) {
        showResult('No Tokens', "You don't have any tokens to use.");
        return;
      }
      if (challengeData.tokenUsedThisRotation) {
        showResult('Token Already Used', 'You can only use one token per rotation.');
        return;
      }
      const withPH = challengeData.slots.filter(s => s.permanentHandicaps.length > 0);
      if (withPH.length === 0) {
        showResult('No Handicaps', 'There are no permanent handicaps to clear.');
        return;
      }
      const slot = withPH[Math.floor(Math.random() * withPH.length)];
      const pick = slot.permanentHandicaps[Math.floor(Math.random() * slot.permanentHandicaps.length)];
      slot.permanentHandicaps = slot.permanentHandicaps.filter(h => h !== pick);
      challengeData.tokens--;
      challengeData.tokenUsedThisRotation = true;
      renderGames();
      updateTokenButton();
      showResult('Token Used', `Cleared a permanent handicap from ${escapeHtml(slot.game)}:<br><strong>${escapeHtml(pick)}</strong>`);
    }

    // Timer
    function startTimer(slotId) {
      const slot = challengeData.slots.find(s => s.id === slotId);
      if (!slot || slot.timerActive) return;
      slot.timerActive = true;
      slot.timerInterval = setInterval(() => {
        slot.timer++;
        if (slot.timer >= 3600) {
          pauseTimer(slotId);
          showResult("Time's Up!", `Your 1-hour session for ${escapeHtml(slot.game || 'this slot')} has ended.`);
        }
        renderGames();
      }, 1000);
      renderGames();
    }

    function pauseTimer(slotId) {
      const slot = challengeData.slots.find(s => s.id === slotId);
      if (!slot || !slot.timerActive) return;
      slot.timerActive = false;
      clearInterval(slot.timerInterval);
      slot.timerInterval = null;
      renderGames();
    }

    function resetTimer(slotId) {
      const slot = challengeData.slots.find(s => s.id === slotId);
      if (!slot) return;
      if (slot.timerInterval) clearInterval(slot.timerInterval);
      slot.timerActive = false;
      slot.timer = 0;
      slot.timerInterval = null;
      renderGames();
    }

    // Database view
    function renderDatabase() {
      const dbList = document.getElementById('databaseList');
      dbList.innerHTML = '';

      // Build sorted game list
      const games = [...challengeData.gameDatabase].sort((a,b) => a.localeCompare(b));
      if (games.length === 0) {
        dbList.innerHTML = '<p>No games in database. Add games to your rotation first or add handicaps here.</p>';
        return;
      }

      games.forEach(game => {
        const perm = challengeData.permHandicaps[game] || [];
        const temp = challengeData.tempHandicaps[game] || [];

        const el = document.createElement('div');
        el.className = 'database-game';
        el.innerHTML = `
          <h3>${escapeHtml(game)}</h3>
          <div class="handicap-list">
            <h4>Permanent Handicaps</h4>
            ${perm.length > 0
              ? perm.map(h => `<div class="db-handicap permanent">${escapeHtml(h)}</div>`).join('')
              : '<p>No permanent handicaps</p>'}
            <h4>Temporary Handicaps</h4>
            ${temp.length > 0
              ? temp.map(h => `<div class="db-handicap temporary">${escapeHtml(h)}</div>`).join('')
              : '<p>No temporary handicaps</p>'}
          </div>
        `;
        dbList.appendChild(el);
      });
    }

    function showAddHandicapModal() {
      const sel = document.getElementById('dbGameSelect');
      sel.innerHTML = '';
      const optNone = document.createElement('option');
      optNone.value = '';
      optNone.textContent = '-- Select existing game --';
      sel.appendChild(optNone);
      // sort for UX
      [...challengeData.gameDatabase].sort((a,b)=>a.localeCompare(b)).forEach(g => {
        const opt = document.createElement('option');
        opt.value = g;
        opt.textContent = g;
        sel.appendChild(opt);
      });
      document.getElementById('dbGameName').value = '';
      document.getElementById('handicapType').value = 'permanent';
      document.getElementById('handicapName').value = '';
      document.getElementById('handicapDescription').value = '';
      document.getElementById('addHandicapModal').style.display = 'flex';
    }

    function addNewHandicap() {
      const gameSelect = document.getElementById('dbGameSelect').value.trim();
      const gameInput = document.getElementById('dbGameName').value.trim();
      const gameName = gameInput || gameSelect;
      const type = document.getElementById('handicapType').value;
      const name = document.getElementById('handicapName').value.trim();
      const description = document.getElementById('handicapDescription').value.trim();

      if (!gameName || !name) {
        alert('Please select or enter a game, and provide a handicap name.');
        return;
      }

      if (!challengeData.gameDatabase.includes(gameName)) {
        challengeData.gameDatabase.push(gameName);
      }
      if (!challengeData.permHandicaps[gameName]) challengeData.permHandicaps[gameName] = [];
      if (!challengeData.tempHandicaps[gameName]) challengeData.tempHandicaps[gameName] = [];

      const full = description ? `${name} - ${description}` : name;
      if (type === 'permanent') {
        challengeData.permHandicaps[gameName].push(full);
      } else {
        challengeData.tempHandicaps[gameName].push(full);
      }

      closeModal('addHandicapModal');
      renderDatabase();
      renderGames(); // updates dropdowns if new game
      saveData();
      showResult('Added to Database', `Added <strong>${escapeHtml(type)}</strong> handicap to <strong>${escapeHtml(gameName)}</strong>:<br><strong>${escapeHtml(full)}</strong>`);
    }

    // Reset progress (not database)
    function showResetModal() {
      document.getElementById('resetModal').style.display = 'flex';
    }

    function resetProgress() {
      challengeData.slots.forEach(s => {
        s.progress = "Not Started";
        s.deaths = 0;
        s.permanentHandicaps = [];
        s.temporaryHandicaps = [];
        if (s.timerInterval) clearInterval(s.timerInterval);
        s.timerInterval = null;
        s.timerActive = false;
        s.timer = 0;
      });
      challengeData.rotationsCompleted = 0;
      challengeData.tokens = 0;
      challengeData.tokenUsedThisRotation = false;

      closeModal('resetModal');
      renderGames();
      updateTokenButton();
      showResult('Progress Reset', 'All progress has been reset. Slots, selected games, and the database remain intact.');
    }

    // Export / Import
    function showExportModal() {
      const exportData = btoa(unescape(encodeURIComponent(JSON.stringify(challengeData))));
      document.getElementById('exportData').value = exportData;
      document.getElementById('exportModal').style.display = 'flex';
    }

    function copyExportData() {
      const ta = document.getElementById('exportData');
      ta.select();
      ta.setSelectionRange(0, 999999);
      document.execCommand('copy');
      showResult('Copied', 'Export seed copied to clipboard.');
    }

    function showImportModal() {
      document.getElementById('importData').value = '';
      document.getElementById('importModal').style.display = 'flex';
    }

    function importChallengeData() {
      const seed = document.getElementById('importData').value.trim();
      if (!seed) {
        alert('Please paste a seed to import.');
        return;
      }
      try {
        const decoded = JSON.parse(decodeURIComponent(escape(atob(seed))));
        // validate minimally
        if (!decoded || typeof decoded !== 'object' || !Array.isArray(decoded.slots)) throw new Error('Invalid seed');
        // stop timers
        if (challengeData.slots) {
          challengeData.slots.forEach(s => { if (s.timerInterval) clearInterval(s.timerInterval); });
        }
        challengeData = decoded;
        // sanitize timers
        challengeData.slots.forEach(s => { s.timerInterval = null; s.timerActive = false; s.timer = s.timer || 0; });

        closeModal('importModal');
        renderGames();
        renderDatabase();
        updateTokenButton();
        saveData();
        showResult('Data Imported', 'Your challenge data has been successfully imported.');
      } catch (e) {
        console.error('Import error', e);
        alert('Invalid seed. Please check your input and try again.');
      }
    }

    // Modals / UI helpers
    function showResult(title, content) {
      document.getElementById('resultTitle').textContent = title;
      document.getElementById('resultContent').innerHTML = content;
      document.getElementById('resultModal').style.display = 'flex';
    }

    function closeModal(id) {
      document.getElementById(id).style.display = 'none';
    }

    function escapeHtml(str) {
      return String(str)
        .replace(/&/g,'&amp;')
        .replace(/</g,'&lt;')
        .replace(/>/g,'&gt;')
        .replace(/"/g,'&quot;')
        .replace(/'/g,'&#39;');
    }
    function escapeAttr(str) {
      return String(str).replace(/'/g, '&#39;').replace(/"/g, '&quot;');
    }

    document.addEventListener('DOMContentLoaded', init);
  </script>
</body>
</html>

