<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Reroll Challenge</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"/>
  <style>
    :root {
      --primary: #2c3e50;
      --secondary: #3498db;
      --accent: #e74c3c;
      --light: #ecf0f1;
      --dark: #2c3e50;
      --success: #2ecc71;
      --warning: #f39c12;
      --purple: #9b59b6;
      --gray: #95a5a6;
    }

    * { box-sizing: border-box; margin: 0; padding: 0; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
    body { background-color: #f5f7fa; color: var(--dark); line-height: 1.6; }
    .container { max-width: 1400px; margin: 0 auto; padding: 20px; }

    header {
      background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
      color: white; padding: 25px; border-radius: 12px; margin-bottom: 25px; text-align: center;
      box-shadow: 0 6px 12px rgba(0,0,0,0.15);
    }
    h1 { margin-bottom: 10px; font-size: 2.5rem; }
    .subtitle { font-style: italic; opacity: 0.9; font-size: 1.1rem; }

    .tabs {
      display: flex; margin-bottom: 20px; background: white; border-radius: 12px; overflow: hidden;
      box-shadow: 0 4px 10px rgba(0,0,0,0.1);
    }
    .tab {
      padding: 15px 20px; cursor: pointer; font-weight: 500; transition: background-color 0.2s; flex: 1; text-align: center;
    }
    .tab:not(.active):hover { background-color: #f8f9fa; }
    .tab.active { background-color: var(--secondary); color: white; }
    .tab-content { display: none; }
    .tab-content.active { display: block; }

    .dashboard { display: grid; grid-template-columns: 1fr 350px; gap: 25px; }
    .games-container { background: white; border-radius: 12px; box-shadow: 0 4px 10px rgba(0,0,0,0.1); padding: 25px; }
    .section-header {
      display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; padding-bottom: 15px; border-bottom: 2px solid var(--light);
    }
    .game-list { display: flex; flex-direction: column; gap: 20px; }
    .game-card {
      border: 1px solid #e0e0e0; border-radius: 10px; padding: 20px; background: white; transition: transform 0.2s, box-shadow 0.2s; position: relative;
    }
    .game-card:hover { transform: translateY(-5px); box-shadow: 0 8px 16px rgba(0,0,0,0.1); }
    .game-card.active-dropdown { z-index: 102; } /* Ensure active card is above siblings */
    .game-card.completed { background-color: #e6ffe6; border-color: var(--success); }
    .game-card.completed .game-title { color: var(--success); }
    .game-card.dragging { opacity: 0.5; border: 2px dashed var(--secondary); }
    .game-card.drag-over { border: 2px solid var(--secondary); }
    .game-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; }
    .game-title { font-weight: bold; font-size: 1.1em; color: var(--primary); display: flex; align-items: center; gap: 10px; }
    .game-title select { padding: 6px 8px; border-radius: 6px; border: 1px solid #ddd; }
    .game-progress { font-size: 0.95em; color: #666; display: flex; gap: 15px; }
    /* Styles for searchable dropdown */
    .searchable-dropdown { position: relative; width: 250px; }
    .searchable-dropdown input { width: 100%; padding: 6px 8px; border-radius: 6px; border: 1px solid #ddd; font-size: 0.95em; }
    .searchable-dropdown-results { position: absolute; top: 100%; left: 0; right: 0; background: white; border: 1px solid #ddd; border-radius: 6px; max-height: 200px; overflow-y: auto; z-index: 100; box-shadow: 0 4px 8px rgba(0,0,0,0.1); }
    .searchable-dropdown-item { padding: 6px 8px; cursor: pointer; font-size: 0.9em; }
    .searchable-dropdown-item:hover { background-color: #f0f0f0; }
    .searchable-dropdown.active { z-index: 101; } /* Ensure active dropdown is above other cards */

    .game-details { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 15px; }
    .handicap-section strong { display: block; margin-bottom: 6px; }
    .handicap {
      background: #f8f9fa; padding: 10px; border-radius: 6px; font-size: 0.9em; margin-bottom: 8px;
      display: flex; justify-content: space-between; align-items: center;
    }
    .handicap.permanent { border-left: 4px solid var(--accent); }
    .handicap.temporary { border-left: 4px solid var(--secondary); }
    .handicap-actions { display: flex; gap: 8px; }
    .handicap-btn { background: none; border: none; cursor: pointer; font-size: 0.9em; color: var(--gray); }
    .handicap-btn:hover { color: var(--accent); }

    .timer-widget {
      display: flex; align-items: center; gap: 10px; margin-top: 10px; padding: 10px; background: #f8f9fa; border-radius: 6px;
    }
    .timer-display { font-family: monospace; font-size: 1.2em; font-weight: bold; }
    .timer-btn { padding: 6px 10px; font-size: 0.9em; }

    .controls { display: flex; gap: 12px; margin-top: 15px; flex-wrap: wrap; }
    button {
      padding: 10px 15px; border: none; border-radius: 6px; cursor: pointer; font-weight: 500; transition: all 0.2s;
      display: inline-flex; align-items: center; gap: 6px;
    }
    .btn-primary { background-color: var(--secondary); color: white; }
    .btn-primary:hover { background-color: #2980b9; transform: translateY(-2px); }
    .btn-danger { background-color: var(--accent); color: white; }
    .btn-danger:hover { background-color: #c0392b; transform: translateY(-2px); }
    .btn-success { background-color: var(--success); color: white; }
    .btn-success:hover { background-color: #27ae60; transform: translateY(-2px); }
    .btn-warning { background-color: var(--warning); color: white; }
    .btn-warning:hover { background-color: #e67e22; transform: translateY(-2px); }
    .btn-purple { background-color: var(--purple); color: white; }
    .btn-purple:hover { background-color: #8e44ad; transform: translateY(-2px); }
    .btn-gray { background-color: #bdc3c7; color: white; cursor: default; }

    .sidebar { display: flex; flex-direction: column; gap: 25px; }
    .panel { background: white; border-radius: 12px; box-shadow: 0 4px 10px rgba(0,0,0,0.1); padding: 20px; }
    .panel h3 { margin-bottom: 15px; padding-bottom: 10px; border-bottom: 2px solid var(--light); color: var(--primary); }

    .action-buttons { display: flex; flex-direction: column; gap: 12px; }
    .action-button { width: 100%; text-align: left; padding: 12px; justify-content: flex-start; }

    .stats { background: #f8f9fa; padding: 15px; border-radius: 8px; }
    .stat-item {
      display: flex; justify-content: space-between; margin-bottom: 10px; padding-bottom: 8px; border-bottom: 1px solid #e0e0e0;
    }
    .stat-item:last-child { border-bottom: none; margin-bottom: 0; padding-bottom: 0; }

    .token-counter {
      display: flex; align-items: center; justify-content: center; gap: 10px; font-size: 1.2em; margin: 15px 0;
    }
    .token-icon { color: var(--warning); font-size: 1.5em; }
    .token-value { font-weight: bold; font-size: 1.3em; }

    footer {
      text-align: center; margin-top: 40px; padding: 25px; color: #7f8c8d; font-size: 0.95em; background: white; border-radius: 12px;
      box-shadow: 0 4px 10px rgba(0,0,0,0.1);
    }

    .database-list { max-height: 500px; overflow-y: auto; }
    .database-game { margin-bottom: 20px; padding-bottom: 15px; border-bottom: 1px solid #eee; }
    .database-game:last-child { border-bottom: none; }
    .handicap-list { margin-left: 20px; }
    .db-handicap { background: #f8f9fa; padding: 8px 10px; border-radius: 6px; margin: 6px 0; display: flex; justify-content: space-between; align-items: center; }
    .db-handicap.permanent { border-left: 4px solid var(--accent); }
    .db-handicap.temporary { border-left: 4px solid var(--secondary); }
    .db-game-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
    .db-game-title { font-weight: bold; font-size: 1.1em; color: var(--primary); }
    .db-game-actions { display: flex; gap: 8px; }
    .handicap-list.hidden { display: none; }

    .modal {
      display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background-color: rgba(0,0,0,0.5); z-index: 1000; justify-content: center; align-items: center;
    }
    .modal-content {
      background: white; padding: 30px; border-radius: 12px; width: 90%; max-width: 700px; max-height: 80vh; overflow-y: auto;
      box-shadow: 0 10px 25px rgba(0,0,0,0.2);
    }
    .modal-header {
      display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; padding-bottom: 15px; border-bottom: 2px solid var(--light);
    }
    .close { font-size: 1.8em; cursor: pointer; color: var(--gray); }
    .close:hover { color: var(--dark); }

    .form-group { margin-bottom: 16px; }
    .form-group label { display: block; margin-bottom: 8px; font-weight: 500; }
    .form-group input, .form-group select, .form-group textarea {
      width: 100%; padding: 12px; border: 1px solid #ddd; border-radius: 6px; font-size: 1em;
    }
    .form-actions { display: flex; justify-content: flex-end; gap: 10px; margin-top: 20px; }

    @media (max-width: 992px) {
      .dashboard { grid-template-columns: 1fr; }
      .game-details { grid-template-columns: 1fr; }
    }
    @media (max-width: 576px) {
      .game-header { flex-direction: column; align-items: flex-start; gap: 10px; }
      .controls { flex-direction: column; }
      .controls button { width: 100%; }
      .tabs { flex-direction: column; }
    }

    hr {
      border: none;
      border-top: 1px solid var(--light);
      margin: 20px 0;
    }

    #rulesContent p, #rulesContent ul {
      margin-bottom: 1em; /* Adds space below paragraphs and lists */
    }

    #rulesContent li {
      margin-bottom: 0.5em; /* Adds space between list items */
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1><i class="fas fa-dice"></i> Reroll Challenge</h1>
      <p class="subtitle">Rotate through games with increasing challenges.</p>
    </header>

    <div class="tabs">
      <div class="tab active" data-tab="challenge">Challenge</div>
      <div class="tab" data-tab="database">Game & Handicap Database</div>
      <div class="tab" data-tab="rules">Rules</div>
    </div>

    <div class="tab-content active" id="challenge-tab">
      <div class="dashboard">
        <div class="games-container">
          <div class="section-header">
            <h2>Your Rotation</h2>
            <div>
              <button class="btn-primary" onclick="addSlot()">
                <i class="fas fa-plus"></i> Add Slot
              </button>
              <button class="btn-danger" onclick="removeSlot()">
                <i class="fas fa-minus"></i> Remove Slot
              </button>
            </div>
          </div>
          <div class="game-list" id="gameList"></div>
        </div>

        <div class="sidebar">
          <div class="panel">
            <h3>Challenge actions</h3>
            <div class="action-buttons">
              <button class="action-button btn-primary" onclick="rollTempHandicap()">
                <i class="fas fa-random"></i> Roll Temporary Handicap
              </button>
              <button class="action-button btn-primary" onclick="rollPermHandicap()">
                <i class="fas fa-random"></i> Roll Permanent Handicap
              </button>
              <button class="action-button btn-success" onclick="completeRotation()">
                <i class="fas fa-flag-checkered"></i> Complete Rotation
              </button>
              <button class="action-button btn-warning" onclick="rollAchievement()">
                <i class="fas fa-trophy"></i> Roll for Achievement Token
              </button>
              <button class="action-button btn-purple" onclick="useToken()" id="useTokenBtn">
                <i class="fas fa-coins"></i> Use Token to Clear Handicap
              </button>
              <button class="action-button btn-danger" onclick="showResetModal()">
                <i class="fas fa-trash-alt"></i> Reset Progress
              </button>
              <button class="action-button btn-primary" onclick="refreshUI()" style="margin-top: 15px;">
                <i class="fas fa-sync-alt"></i> Refresh UI
              </button>
            </div>
          </div>

          <div class="panel">
            <h3>Game stats</h3>
            <div class="stats">
              <div class="stat-item">
                <span>Total Games:</span>
                <span id="totalGames">0</span>
              </div>
              <div class="stat-item">
                <span>Completed:</span>
                <span id="completedGames">0</span>
              </div>
              <div class="stat-item">
                <span>Active Handicaps:</span>
                <span id="activeHandicaps">0</span>
              </div>
              <div class="stat-item">
                <span id="totalDeathsLabel">Total Deaths:</span>
                <span id="totalDeaths">0</span>
              </div>
              <div class="stat-item">
                <span>Rotations Completed:</span>
                <span id="rotationsCompleted">0</span>
              </div>
            </div>

            <div class="token-counter">
              <i class="fas fa-coins token-icon"></i>
              <span>Tokens:</span>
              <span class="token-value" id="tokenCount">0</span>
            </div>
          </div>

          <div class="panel">
            <h3>Data management</h3>
            <div class="action-buttons">
              <button class="action-button btn-primary" onclick="showExportModal()">
                <i class="fas fa-file-export"></i> Export Seed
              </button>
              <button class="action-button btn-primary" onclick="showImportModal()">
                <i class="fas fa-file-import"></i> Import Seed
              </button>
            </div>
            <div class="stat-item" style="margin-top: 20px;">
              <span>Total Completed Runs:</span>
              <span id="totalCompletedRunsDisplay">0</span>
              <button class="handicap-btn" title="Clear Total Completed Runs" onclick="clearTotalCompletedRuns()">
                <i class="fas fa-times"></i>
              </button>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="tab-content" id="database-tab">
      <div class="panel">
        <div class="section-header">
          <h2>Game & Handicap Database</h2>
          <button class="btn-primary" onclick="showAddHandicapModal()">
            <i class="fas fa-plus"></i> Add to Database
          </button>
        </div>
        <div class="form-group" style="margin-bottom: 20px;">
          <input type="text" id="databaseSearchInput" placeholder="Search games..." onkeyup="renderDatabase()" style="width: 100%; padding: 10px; border-radius: 6px; border: 1px solid #ddd;"/>
        </div>
        <div class="database-list" id="databaseList"></div>
      </div>
    </div>

    <div class="tab-content" id="rules-tab">
      <div class="panel">
        <div class="section-header">
          <h2 id="rulesPageTitle">Reroll Challenge rules</h2>
          <div>
            <button class="btn-primary" onclick="toggleRulesPageMode()">
              <i class="fas fa-cog"></i> <span id="rulesPageToggleButtonText">Show Settings</span>
            </button>
            <button class="btn-primary" onclick="refreshUI()" style="margin-left: 10px;">
              <i class="fas fa-sync-alt"></i> Refresh
            </button>
          </div>
        </div>

        <div id="rulesContent">
          <h3>Concept</h3>
          <p>The Reroll Challenge began as a way for me to have fun clearing my backlog, games I otherwise was not going to play. It worked by rotating through multiple titles with escalating constraints, keeping things fresh and giving me a reason to stick with them.</p>
          <p>It has since grown into a modular framework & ruleset that can be shaped to fit almost any style of play. Much like a Nuzlocke run in Pokémon, it is a self‑imposed challenge designed to make familiar games feel new again, but here the structure is more streamlined and consistent thanks to the app automatically tracking timers, rotations, and handicaps for you.  </p>
          <p>You can <strong>build your own pool of games</strong> for any platform or genre. You can <strong>create custom handicap lists</strong>, split into permanent and temporary rules, which are then pulled at random during play to keep you adapting on the fly. You can <strong>adjust rotation rules</strong> to swap games after a set time, a death, a level, or any trigger you choose. You can <strong>dynamically set different timers</strong> for each game, so a speedrun segment might get 15 minutes while a longer endurance section gets an hour. You can <strong>export and import seeds</strong> so others can run the exact same setup, whether for casual play, community races, or competitive speedruns.</p>
          <p>Because the system does not hook into game code, it works with any game. You can apply the same framework to everything you play and customise the rules to fit your style. A long form endurance run might rotate between three RPGs, each with its own 90 minute timer and strict resource limits. A short experimental session could cycle through several platformers in 10 minute bursts with temporary handicaps like "must keep moving" or "no jumping for 30 seconds." A structured speedrun race could give each game a different timer based on its category length, paired with handicaps that force new routes or strategies. A community challenge night might use a viewer submitted seed with a curated mix of games, timers, and rules that everyone can load and attempt.</p>
          <hr>

          <h3>Rotation and Sessions</h3>
          <p>Set up <strong>1–10 slots</strong>, each representing one game in your rotation order. The challenge works with any number, but more slots create more variety and allow temporary handicaps to spread across multiple games. Slots can also be used for different categories of the same game, alternate save files, or different difficulty settings.</p>
          <p>Each session lasts <strong>1 hour per slot</strong>, tracked with the slot's timer widget. The timer length is fully adjustable per slot. You can give a speedrun segment 15 minutes, a grind heavy RPG 90 minutes, or run without a timer for a play until death format.</p>
          <p>Progress through slots in order. When the final slot finishes, the rotation repeats. At the end of each rotation, all temporary handicaps are cleared.</p>
          <hr>

          <h3>Deaths and Temporary Handicaps</h3>
          <p>When you die in a slot, immediately switch to the next slot. You can change this trigger to something else, such as swapping on boss defeat, level completion, or a set number of in game days.</p>
          <p>That death also triggers a <strong>temporary handicap</strong> assigned to a future slot within the same rotation. Only slots appearing after the current slot can receive the handicap. Slot 1 is immune to temporary handicaps caused in prior rotations, since all temps clear at rotation end.</p>
          <p>Temporary handicaps always last <strong>one session</strong> and naturally stack if multiple deaths target the same future slot. In a large rotation, the final slot can end up carrying several temporary handicaps at once.</p>
          <hr>

          <h3>Permanent Handicaps</h3>
          <p>Permanent handicaps are <strong>game specific constraints</strong> that persist across rotations. You can make these as light or as punishing as you want, from "no fast travel" to "permadeath for party members."</p>
          <p>Each game can have a maximum of <strong>3 permanent handicaps</strong> to avoid softlocks. The option to raise or lower this cap will be added in a future update.</p>
          <p>Rolling a permanent handicap selects from that game's database pool, avoiding duplicates.</p>
          <p>At the end of each rotation there is a <strong>1% chance</strong> to clear all permanent handicaps. This chance is configurable in the <strong>Optional Rules (Settings)</strong> page.</p>
          <p><strong>Beating a game completely</strong> immediately clears <strong>2–3 random permanent handicaps</strong> from your active slots, giving a strong incentive to finish titles rather than just rotate through them.</p>
          <hr>

          <h3>Tokens and Achievements</h3>
          <p>Every achievement earned (in any game) has a <strong>20% chance</strong> to grant a token. This chance is configurable in the <strong>Optional Rules (Settings)</strong> page, where you can also tie tokens to other milestones.</p>
          <p>Tokens can clear <strong>one permanent handicap</strong>.</p>
          <p>You may use at most <strong>one token per rotation</strong>.</p>
          <hr>

          <h3>Rotation End</h3>
          <p>Finishing a rotation (dying in the final game, or reaching the hour timer) clears all temporary handicaps.</p>
          <p>There is a <strong>1% chance</strong> at rotation end to also clear all permanent handicaps (configurable in the <strong>Optional Rules (Settings)</strong> page).</p>
          <p>The rotation counter increases by one, and token usage limits reset.</p>
          <hr>

          <h3>Database and Slots</h3>
          <p>Maintain a database of games with separate pools for permanent and temporary handicaps. You can keep multiple databases for different genres, difficulty levels, or community events.</p>
          <p>Each slot lets you select a game from the database via a dropdown.</p>
          <p>Handicaps are automatically pulled for whatever game is actively slotted.</p>
          <p>Manual handicap assignment is now available and can be enabled in the <strong>Optional Rules (Settings)</strong> page for curated challenges.</p>
          <hr>

          <h3>Goal</h3>
          <p>Clear all games in the <strong>fewest rotations possible</strong>. Fewer deaths, smarter plays, faster clears. Clearing a game entirely not only removes it from your backlog but also clears <strong>3–4 random permanent handicaps</strong>, making it a powerful way to improve your odds in the rest of the challenge. Or adapt the system for variety streaming, speedrun gauntlets, or community challenge events.</p>
        </div>

        <div id="settingsContent" style="display: none;">
          <h2>Reroll Challenge Settings</h2>
          <p>Here you can customize various aspects of your challenge.</p>

          <div style="background-color: #fff3cd; border-left: 4px solid #ffc107; padding: 10px; margin-bottom: 20px; border-radius: 4px; color: #664d03;">
            <strong>Note:</strong> Some changes may require a UI refresh to take full effect. Click the 'Refresh' button above.
          </div>

          <div class="form-group">
            <label for="tokenDropRateInput">Achievement Token Drop Rate (%)</label>
            <input type="number" id="tokenDropRateInput" min="0" max="100" step="1" value="20" onchange="updateSetting('tokenDropRate', this.value / 100)" />
            <p class="hint">Every achievement earned has this chance to grant a token. Default: 20%</p>
          </div>

          <div class="form-group">
            <label for="permClearChanceInput">Rotation End Permanent Handicap Clear Chance (%)</label>
            <input type="number" id="permClearChanceInput" min="0" max="100" step="1" value="1" onchange="updateSetting('permClearChance', this.value / 100)" />
            <p class="hint">At the end of each rotation, all permanent handicaps have this chance to be cleared. Default: 1%</p>
          </div>

          <div class="form-group">
            <label for="manualHandicapsToggle">Enable Manual Handicap Assignment</label>
            <input type="checkbox" id="manualHandicapsToggle" onchange="updateSetting('manualHandicapsEnabled', this.checked)" />
            <p class="hint">Allows manual assignment of handicaps to slots, overriding automatic rolls. Default: Disabled</p>
          </div>

          <div class="form-group">
            <label for="deathSystemNameInput">Name of Death Mechanic</label>
            <input type="text" id="deathSystemNameInput" value="Deaths" onchange="updateSetting('deathSystemName', this.value)" />
            <p class="hint">Customize the name for the 'Deaths' mechanic. This will update throughout the application. Default: Deaths</p>
          </div>

          <div class="form-group">
            <label for="disableAutomatedHandicapGainsToggle">Disable Automated Handicap Gains (experimental)</label>
            <input type="checkbox" id="disableAutomatedHandicapGainsToggle" onchange="updateSetting('disableAutomatedHandicapGains', this.checked)" />
            <p class="hint">If enabled, temporary and permanent handicaps will not be automatically added after deaths or rotation completion. Default: Disabled</p>
          </div>

          <div class="form-group">
            <label for="disableAutomatedHandicapRemovalsToggle">Disable Automated Handicap Removals (experimental)</label>
            <input type="checkbox" id="disableAutomatedHandicapRemovalsToggle" onchange="updateSetting('disableAutomatedHandicapRemovals', this.checked)" />
            <p class="hint">If enabled, permanent handicaps will not be automatically removed when a game is completed or at rotation end. Default: Disabled</p>
          </div>
        </div>
      </div>
    </div>

    <footer>
      <p>Reroll Challenge v1.2 — Share with friends and challenge yourselves!</p>
    </footer>
  </div>

  <!-- Add Handicap Modal -->
  <div class="modal" id="addHandicapModal">
    <div class="modal-content">
      <div class="modal-header">
        <h2>Add to database</h2>
        <span class="close" onclick="closeModal('addHandicapModal')">&times;</span>
      </div>
      <div class="form-group">
        <label for="dbGameName">Game</label>
        <div style="display:flex; gap:10px;">
          <select id="dbGameSelect" style="flex:1"></select>
          <input id="dbGameName" placeholder="Or type a new game" style="flex:1"/>
        </div>
      </div>
      <div class="form-group">
        <label for="handicapType">Handicap type</label>
        <select id="handicapType">
          <option value="permanent">Permanent</option>
          <option value="temporary">Temporary</option>
        </select>
      </div>
      <div class="form-group">
        <label for="handicapName">Handicap name</label>
        <input id="handicapName" placeholder="Enter handicap name"/>
      </div>
      <div class="form-group">
        <label for="handicapDescription">Description (optional)</label>
        <textarea id="handicapDescription" placeholder="Enter description"></textarea>
      </div>
      <div class="form-group">
        <label for="bulkHandicaps">Add multiple handicaps (one per line)</label>
        <textarea id="bulkHandicaps" rows="6" placeholder="Enter handicaps, one per line"></textarea>
      </div>
      <div class="form-actions">
        <button class="btn-danger" onclick="closeModal('addHandicapModal')">Cancel</button>
        <button class="btn-primary" onclick="addBulkHandicaps()">Add All</button>
        <button class="btn-success" onclick="addNewHandicap()">Add Single</button>
      </div>
    </div>
  </div>

  <!-- Edit Game Modal -->
  <div class="modal" id="editGameModal">
    <div class="modal-content">
      <div class="modal-header">
        <h2>Edit Game Name</h2>
        <span class="close" onclick="closeModal('editGameModal')">&times;</span>
      </div>
      <input type="hidden" id="originalGameName">
      <div class="form-group">
        <label for="editedGameName">Game Name</label>
        <input id="editedGameName" placeholder="Enter new game name"/>
      </div>
      <div class="form-actions">
        <button class="btn-danger" onclick="closeModal('editGameModal')">Cancel</button>
        <button class="btn-success" onclick="saveEditedGame()">Save Changes</button>
      </div>
    </div>
  </div>

  <!-- Edit Handicap Modal -->
  <div class="modal" id="editHandicapModal">
    <div class="modal-content">
      <div class="modal-header">
        <h2>Edit Handicap</h2>
        <span class="close" onclick="closeModal('editHandicapModal')">&times;</span>
      </div>
      <!-- Hidden fields to store original handicap data -->
      <input type="hidden" id="originalEditGameName">
      <input type="hidden" id="originalEditHandicapType">
      <input type="hidden" id="originalEditHandicap">
      <div class="form-group">
        <label for="editGameName">Game</label>
        <div style="display:flex; gap:10px;">
          <select id="editGameSelect" style="flex:1"></select>
          <input id="editGameName" placeholder="Or type a new game" style="flex:1"/>
        </div>
      </div>
      <div class="form-group">
        <label for="editHandicapType">Handicap type</label>
        <select id="editHandicapType">
          <option value="permanent">Permanent</option>
          <option value="temporary">Temporary</option>
        </select>
      </div>
      <div class="form-group">
        <label for="editHandicapName">Handicap name</label>
        <input id="editHandicapName" placeholder="Enter handicap name"/>
      </div>
      <div class="form-group">
        <label for="editHandicapDescription">Description (optional)</label>
        <textarea id="editHandicapDescription" placeholder="Enter description"></textarea>
      </div>
      <div class="form-actions">
        <button class="btn-danger" onclick="closeModal('editHandicapModal')">Cancel</button>
        <button class="btn-success" onclick="saveEditedHandicap()">Save</button>
      </div>
    </div>
  </div>

  <!-- Reset Modal -->
  <div class="modal" id="resetModal">
    <div class="modal-content">
      <div class="modal-header">
        <h2>Reset progress</h2>
        <span class="close" onclick="closeModal('resetModal')">&times;</span>
      </div>
      <p>This will clear deaths, timers, temporary handicaps, permanent handicaps attached to slots, token usage in rotation, tokens, and rotations count.</p>
      <div class="form-actions">
        <button class="btn-primary" onclick="closeModal('resetModal')">Cancel</button>
        <button class="btn-danger" onclick="resetProgress()">Reset Progress</button>
      </div>
    </div>
  </div>

  <!-- Export Modal -->
  <div class="modal" id="exportModal">
    <div class="modal-content">
      <div class="modal-header">
        <h2>Export seed</h2>
        <span class="close" onclick="closeModal('exportModal')">&times;</span>
      </div>
      <p>Copy the seed below to save your entire challenge state (slots, timers, handicaps, database, tokens, etc.).</p>
      <div class="form-group">
        <textarea id="exportData" rows="8" readonly style="width:100%; font-family:monospace;"></textarea>
      </div>
      <div class="form-actions">
        <button class="btn-primary" onclick="copyExportData()"><i class="fas fa-copy"></i> Copy</button>
        <button class="btn-danger" onclick="closeModal('exportModal')">Close</button>
      </div>
    </div>
  </div>

  <!-- Manual Assign Handicap Modal -->
  <div class="modal" id="manualAssignHandicapModal">
    <div class="modal-content">
      <div class="modal-header">
        <h2>Manually Assign Handicap</h2>
        <span class="close" onclick="closeModal('manualAssignHandicapModal')">&times;</span>
      </div>
      <input type="hidden" id="manualAssignSlotId">
      <div class="form-group">
        <label for="manualAssignGameName">Game</label>
        <input type="text" id="manualAssignGameName" readonly />
      </div>
      <div class="form-group">
        <label for="manualAssignHandicapType">Handicap type</label>
        <select id="manualAssignHandicapType" onchange="populateManualHandicaps()">
          <option value="permanent">Permanent</option>
          <option value="temporary">Temporary</option>
        </select>
      </div>
      <div class="form-group">
        <label for="manualAssignHandicap">Select Handicap</label>
        <select id="manualAssignHandicap">
          <option value="">-- Select a handicap --</option>
        </select>
      </div>
      <div class="form-actions">
        <button class="btn-danger" onclick="closeModal('manualAssignHandicapModal')">Cancel</button>
        <button class="btn-success" onclick="assignManualHandicap()">Assign</button>
      </div>
    </div>
  </div>

  <!-- Import Modal -->
  <div class="modal" id="importModal">
    <div class="modal-content">
      <div class="modal-header">
        <h2>Import seed</h2>
        <span class="close" onclick="closeModal('importModal')">&times;</span>
      </div>
      <p>Paste a previously exported seed to restore everything.</p>
      <div class="form-group">
        <textarea id="importData" rows="8" style="width:100%; font-family:monospace;" placeholder="Paste seed here"></textarea>
      </div>
      <div class="form-actions">
        <button class="btn-success" onclick="importChallengeData()"><i class="fas fa-file-import"></i> Import</button>
        <button class="btn-danger" onclick="closeModal('importModal')">Cancel</button>
      </div>
    </div>
  </div>

  <!-- Result Modal -->
  <div class="modal" id="resultModal">
    <div class="modal-content">
      <div class="modal-header">
        <h2 id="resultTitle">Result</h2>
        <span class="close" onclick="closeModal('resultModal')">&times;</span>
      </div>
      <div id="resultContent"></div>
    </div>
  </div>

  <script>
    // Core data
    let challengeData = {
      slots: [],
      rotationsCompleted: 0,
      tokens: 0,
      tokenUsedThisRotation: false,
      gameDatabase: [],
      permHandicaps: {},
      tempHandicaps: {},
      totalCompletedRuns: 0, // New counter for total completed runs
      // New modular rules page settings
      tokenDropRate: 0.20, // 20% chance
      permClearChance: 0.01, // 1% chance
      manualHandicapsEnabled: false, // Default to false
      deathSystemName: 'Deaths', // Default name for the death mechanic
      disableAutomatedHandicapGains: false, // Default to false (experimental)
      disableAutomatedHandicapRemovals: false // Default to false (experimental)
    };

    // Sample seeds for first run
    const sampleGames = [
      "Vampire: The Masquerade – Bloodlines",
      "Enderal",
      "Amazing Cultivation Simulator",
      "Fallout 76",
      "Age of Decadence"
    ];
    const samplePermHandicaps = {
      "Vampire: The Masquerade – Bloodlines": [
        "Clan Loyalty - Must pick one Discipline and always prioritize it when spending XP",
        "No Easy Meal - Must avoid feeding on innocents; only feed on criminals, enemies, or blood packs"
      ],
      "Enderal": [
        "Ascetic Path - No food/drink buffs",
        "Class Purist - Stick to one archetype tree"
      ],
      "Amazing Cultivation Simulator": [
        "No Outer Sect - Cannot recruit or interact with any outer sects for the rest of the run",
        "One Life - If a disciple dies, the run ends"
      ],
      "Fallout 76": [
        "Scavenger Only - No vendor purchases",
        "Pacifist Trades - No PvP engagements"
      ],
      "Age of Decadence": [
        "No Save Scum - One try per check",
        "Faction Loyalist - Commit to first faction choice"
      ]
    };
    const sampleTempHandicaps = {
      "Vampire: The Masquerade – Bloodlines": [
        "Hunger Unchecked - Cannot feed until the end of the current questline",
        "Beast's Restraint - No blood disciplines in one major dungeon"
      ],
      "Enderal": [
        "The Long Night - Travel only by night",
        "Blind Pilgrim - No map use for one major journey"
      ],
      "Amazing Cultivation Simulator": [
        "One Disciple Sect - Limit recruitment to one disciple for this session",
        "Manual Labor Only - No automation this session"
      ],
      "Fallout 76": [
        "Iron Stomach - No food buffs this session",
        "Barebones - No Power Armor this session"
      ],
      "Age of Decadence": [
        "No Merchants - Use only looted gear this session",
        "Silent Tongue - No persuasion checks this session"
      ]
    };

    // Init
    function init() {
      const saved = localStorage.getItem('rerollChallengeData');
      if (saved) {
        try {
          challengeData = JSON.parse(saved);
          // Ensure totalCompletedRuns is a number
          challengeData.totalCompletedRuns = Number(challengeData.totalCompletedRuns) || 0;
          // Ensure new settings have default values if not present in saved data
          challengeData.tokenDropRate = challengeData.tokenDropRate !== undefined ? challengeData.tokenDropRate : 0.20;
          challengeData.permClearChance = challengeData.permClearChance !== undefined ? challengeData.permClearChance : 0.01;
          challengeData.manualHandicapsEnabled = challengeData.manualHandicapsEnabled !== undefined ? challengeData.manualHandicapsEnabled : false;
          challengeData.deathSystemName = challengeData.deathSystemName || 'Deaths';
          challengeData.disableAutomatedHandicapGains = challengeData.disableAutomatedHandicapGains !== undefined ? challengeData.disableAutomatedHandicapGains : false;
          challengeData.disableAutomatedHandicapRemovals = challengeData.disableAutomatedHandicapRemovals !== undefined ? challengeData.disableAutomatedHandicapRemovals : false;

          // Clean up timer intervals if any persisted incorrectly
          challengeData.slots.forEach(s => { s.timerInterval = null; s.timerActive = false; });
        } catch {
          loadSample();
        }
      } else {
        loadSample();
      }
      ensureAtLeastThreeSlots();

      renderGames();
      updateStats();
      updateTokenButton();
      renderDatabase();
      setupTabs();
      renderSettings(); // Initialize settings UI
    }

    function loadSample() {
      challengeData = {
        slots: [],
        rotationsCompleted: 0,
        tokens: 0,
        tokenUsedThisRotation: false,
        gameDatabase: [...sampleGames],
        permHandicaps: JSON.parse(JSON.stringify(samplePermHandicaps)),
        tempHandicaps: JSON.parse(JSON.stringify(sampleTempHandicaps)),
        totalCompletedRuns: 0 // Initialize for sample data
      };
    }

    function ensureAtLeastThreeSlots() {
      while (challengeData.slots.length < 3) {
        challengeData.slots.push(newSlot(challengeData.slots.length + 1));
      }
    }

    function newSlot(id) {
      return {
        id,
        game: "",
        progress: "Not Started",
        deaths: 0,
        permanentHandicaps: [],
        temporaryHandicaps: [],
        timer: 3600, // Initialize to 60 minutes (3600 seconds)
        timerActive: false,
        timerInterval: null,
        sessionDuration: 3600 // New property for customizable duration
      };
    }

    function saveData() {
      localStorage.setItem('rerollChallengeData', JSON.stringify(challengeData));
    }

    // Tabs
    function setupTabs() {
      document.querySelectorAll('.tab').forEach(tab => {
        tab.addEventListener('click', () => {
          const name = tab.getAttribute('data-tab');
          document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
          document.querySelectorAll('.tab-content').forEach(tc => tc.classList.remove('active'));
          tab.classList.add('active');
          document.getElementById(`${name}-tab`).classList.add('active');
        });
      });
    }

    // Render challenge slots
    function renderGames() {
      const gameList = document.getElementById('gameList');
      gameList.innerHTML = '';

      const activeSlots = challengeData.slots.filter(s => s.progress !== 'Completed').sort((a,b) => a.id - b.id);
      const completedSlots = challengeData.slots.filter(s => s.progress === 'Completed').sort((a,b) => a.id - b.id);

      activeSlots.forEach(slot => {
        const card = document.createElement('div');
        card.className = 'game-card';
        card.setAttribute('draggable', 'true');
        card.setAttribute('data-slot-id', slot.id);

        const timerMinutes = Math.floor(slot.timer / 60);
        const timerSeconds = slot.timer % 60;
        const timerDisplay = `${timerMinutes.toString().padStart(2, '0')}:${timerSeconds.toString().padStart(2, '0')}`;

        card.innerHTML = `
          <div class="game-header">
            <div class="game-title">
              <span>Slot ${slot.id}</span>
              <div class="searchable-dropdown" id="game-select-${slot.id}">
                <input type="text" placeholder="Select a game..." value="${escapeAttr(slot.game)}" onfocus="this.select(); renderSearchableDropdown(this, ${slot.id});" oninput="renderSearchableDropdown(this, ${slot.id});" onblur="hideSearchableDropdown(this);" data-slot-id="${slot.id}"/>
                <div class="searchable-dropdown-results"></div>
              </div>
            </div>
            <div class="game-progress">
              <span>${challengeData.deathSystemName}: ${slot.deaths}</span>
            </div>
          </div>

          ${slot.game ? `
            <div class="game-details">
              <div class="handicap-section">
                <strong>Permanent Handicaps</strong>
                ${slot.permanentHandicaps.length > 0 ?
                  slot.permanentHandicaps.map(h => `
                    <div class="handicap permanent">
                      <span>${escapeHtml(h)}</span>
                      <div class="handicap-actions">
                        <button class="handicap-btn" title="Remove" onclick="clearSpecificHandicap(${slot.id}, 'permanent', '${escapeAttr(h)}')">
                          <i class="fas fa-times"></i>
                        </button>
                      </div>
                    </div>
                  `).join('') : `<div class="handicap">None</div>`
                }
              </div>
              <div class="handicap-section">
                <strong>Temporary Handicaps</strong>
                ${slot.temporaryHandicaps.length > 0 ?
                  slot.temporaryHandicaps.map(h => `
                    <div class="handicap temporary">
                      <span>${escapeHtml(h)}</span>
                      <div class="handicap-actions">
                        <button class="handicap-btn" title="Remove" onclick="clearSpecificHandicap(${slot.id}, 'temporary', '${escapeAttr(h)}')">
                          <i class="fas fa-times"></i>
                        </button>
                      </div>
                    </div>
                  `).join('') : `<div class="handicap">None</div>`
                }
              </div>
            </div>

            <div class="timer-widget">
              <div class="timer-display">${timerDisplay}</div>
              <button class="timer-btn btn-success" ${slot.timerActive ? 'disabled' : ''} onclick="startTimer(${slot.id})">
                <i class="fas fa-play"></i> Start
              </button>
              <button class="timer-btn btn-warning" ${!slot.timerActive ? 'disabled' : ''} onclick="pauseTimer(${slot.id})">
                <i class="fas fa-pause"></i> Pause
              </button>
              <button class="timer-btn btn-danger" onclick="resetTimer(${slot.id})">
                <i class="fas fa-redo"></i> Reset
              </button>
              <div style="margin-left: auto;">
                <label for="duration-${slot.id}" style="font-size: 0.9em;">Duration (min):</label>
                <input type="number" id="duration-${slot.id}" value="${slot.sessionDuration / 60}" min="1" onchange="updateSessionDuration(${slot.id}, this.value)" style="width: 60px; padding: 4px; border-radius: 4px; border: 1px solid #ddd;"/>
              </div>
            </div>

            <div class="controls">
              <button class="btn-primary" onclick="addDeath(${slot.id})">
                <i class="fas fa-skull"></i> Add ${challengeData.deathSystemName === 'Deaths' ? 'Death' : challengeData.deathSystemName}
              </button>
              <button class="btn-success" onclick="markComplete(${slot.id})">
                <i class="fas fa-check"></i> Mark Complete
              </button>
              ${challengeData.manualHandicapsEnabled && slot.game ? `
                <button class="btn-info" onclick="showManualAssignHandicapModal(${slot.id})">
                  <i class="fas fa-wrench"></i> Assign Handicap
                </button>
              ` : ''}
            </div>
          ` : `
            <div class="handicap">Select a game from the dropdown to begin.</div>
          `}
        `;
        gameList.appendChild(card);
      });

      // Add drag and drop event listeners
      let draggedItem = null;

      document.querySelectorAll('.game-card').forEach(card => {
        card.addEventListener('dragstart', (e) => {
          if (card.classList.contains('completed')) {
            e.preventDefault(); // Prevent dragging completed slots
            return;
          }
          draggedItem = card;
          setTimeout(() => card.classList.add('dragging'), 0);
          e.dataTransfer.effectAllowed = 'move';
          e.dataTransfer.setData('text/plain', card.dataset.slotId);
        });

        card.addEventListener('dragover', (e) => {
          e.preventDefault(); // Allow drop
          if (card !== draggedItem && !card.classList.contains('completed')) {
            card.classList.add('drag-over');
          }
        });

        card.addEventListener('dragleave', () => {
          card.classList.remove('drag-over');
        });

        card.addEventListener('drop', (e) => {
          e.preventDefault();
          card.classList.remove('drag-over');

          if (draggedItem && card !== draggedItem && !card.classList.contains('completed')) {
            const draggedId = parseInt(draggedItem.dataset.slotId);
            const droppedId = parseInt(card.dataset.slotId);

            const newSlots = [...challengeData.slots];
            const draggedSlotIndex = newSlots.findIndex(s => s.id === draggedId);
            const droppedSlotIndex = newSlots.findIndex(s => s.id === droppedId);

            const [removed] = newSlots.splice(draggedSlotIndex, 1);
            newSlots.splice(droppedSlotIndex, 0, removed);

            // Reassign IDs based on new order and re-render
            challengeData.slots = newSlots.map((s, index) => ({ ...s, id: index + 1 }));
            renderGames();
          }
          draggedItem.classList.remove('dragging');
          draggedItem = null;
        });

        card.addEventListener('dragend', () => {
          if (draggedItem) {
            draggedItem.classList.remove('dragging');
            draggedItem = null;
          }
          document.querySelectorAll('.game-card').forEach(c => c.classList.remove('drag-over'));
        });
      });

      if (completedSlots.length > 0) {
        const completedHeader = document.createElement('h2');
        completedHeader.textContent = 'Completed Games';
        completedHeader.style.marginTop = '30px';
        completedHeader.style.borderBottom = '2px solid var(--light)';
        completedHeader.style.paddingBottom = '15px';
        gameList.appendChild(completedHeader);

        completedSlots.forEach(slot => {
          const card = document.createElement('div');
          card.className = 'game-card completed';

          card.innerHTML = `
            <div class="game-header">
              <div class="game-title">
                <i class="fas fa-check-circle" style="color: var(--success);"></i>
                <span>Slot ${slot.id}: ${escapeHtml(slot.game || 'N/A')}</span>
              </div>
              <div class="game-progress">
                <span>Completed | Deaths: ${slot.deaths}</span>
              </div>
            </div>
            <div class="handicap">Game completed! No new handicaps.</div>
          `;
          gameList.appendChild(card);
        });
      }

      updateStats();
      saveData();
    }

    // Stats
    function updateStats() {
      const completed = challengeData.slots.filter(s => s.progress === 'Completed').length;
      const activeHandicaps = challengeData.slots.reduce((t, s) => t + s.permanentHandicaps.length + s.temporaryHandicaps.length, 0);
      const totalDeaths = challengeData.slots.reduce((t, s) => t + s.deaths, 0);
      const totalGames = challengeData.slots.filter(s => !!s.game).length;

      document.getElementById('totalGames').textContent = totalGames;
      document.getElementById('completedGames').textContent = completed;
      document.getElementById('activeHandicaps').textContent = activeHandicaps;
      document.getElementById('totalDeaths').textContent = totalDeaths;
      document.getElementById('rotationsCompleted').textContent = challengeData.rotationsCompleted;
      document.getElementById('tokenCount').textContent = challengeData.tokens;
      document.getElementById('totalCompletedRunsDisplay').textContent = challengeData.totalCompletedRuns; // Update the new counter display

      // Update the death system name in the sidebar stat item title
      document.getElementById('totalDeathsLabel').textContent = `${challengeData.deathSystemName}:`;
    }

    // Token button
    function updateTokenButton() {
      const btn = document.getElementById('useTokenBtn');
      if (challengeData.tokens > 0 && !challengeData.tokenUsedThisRotation) {
        btn.disabled = false;
        btn.classList.remove('btn-gray');
        btn.classList.add('btn-purple');
      } else {
        btn.disabled = true;
        btn.classList.remove('btn-purple');
        btn.classList.add('btn-gray');
      }
    }

    // Slot mgmt
    function addSlot() {
      if (challengeData.slots.length >= 10) {
        showResult('Maximum Slots', 'You can only have up to 10 slots.');
        return;
      }
      const id = challengeData.slots.length + 1;
      challengeData.slots.push(newSlot(id));
      renderGames();
      showResult('Slot Added', 'Added a new slot to your rotation.');
    }

    function removeSlot() {
      if (challengeData.slots.length <= 3) {
        showResult('Minimum Slots', 'You must have at least 3 slots.');
        return;
      }
      const removed = challengeData.slots.pop();
      // Stop timer if running
      if (removed.timerInterval) clearInterval(removed.timerInterval);
      renderGames();
      showResult('Slot Removed', 'Removed the last slot from your rotation.');
    }

    function updateGame(slotId, gameName) {
      const slot = challengeData.slots.find(s => s.id === slotId);
      if (!slot) return;

      slot.game = gameName || "";
      if (slot.game) {
        // ensure in database
        if (!challengeData.gameDatabase.includes(slot.game)) {
          challengeData.gameDatabase.push(slot.game);
        }
        if (!challengeData.permHandicaps[slot.game]) challengeData.permHandicaps[slot.game] = [];
        if (!challengeData.tempHandicaps[slot.game]) challengeData.tempHandicaps[slot.game] = [];
      }

      renderGames();
      renderDatabase();
      saveData();
    }

    // Deaths
    function addDeath(slotId) {
      const slot = challengeData.slots.find(s => s.id === slotId);
      if (!slot || !slot.game) {
        showResult('No Game Selected', 'Please select a game for this slot before adding deaths.');
        return;
      }

      slot.deaths++;
      
      if (challengeData.disableAutomatedHandicapGains) {
        renderGames();
        showResult('Death Added', `Added a ${challengeData.deathSystemName === 'Deaths' ? 'death' : challengeData.deathSystemName.toLowerCase()} to ${escapeHtml(slot.game)}. Automated handicap gains are disabled.`);
        return;
      }

      // Assign temp handicap to a future slot with a game, excluding Slot 1 and completed slots
      const futureSlots = challengeData.slots.filter(s => s.id > slotId && s.game && s.id !== 1 && s.progress !== 'Completed');
      if (futureSlots.length === 0) {
        renderGames();
        showResult('Death Added', `Added a ${challengeData.deathSystemName === 'Deaths' ? 'death' : challengeData.deathSystemName.toLowerCase()} to ${escapeHtml(slot.game)}.<br>No eligible future slots to assign temporary handicaps.`);
        return;
      }
      const target = futureSlots[Math.floor(Math.random() * futureSlots.length)];
      const pool = challengeData.tempHandicaps[target.game] || [];
      if (pool.length > 0) {
        const randomHandicap = pool[Math.floor(Math.random() * pool.length)];
        target.temporaryHandicaps.push(randomHandicap);
        renderGames();
        showResult('Death Added', `Added a ${challengeData.deathSystemName === 'Deaths' ? 'death' : challengeData.deathSystemName.toLowerCase()} to ${escapeHtml(slot.game)}.<br>Temporary handicap added to ${escapeHtml(target.game)}:<br><strong>${escapeHtml(randomHandicap)}</strong>`);
        return;
      }
      renderGames();
      showResult('Death Added', `Added a ${challengeData.deathSystemName === 'Deaths' ? 'death' : challengeData.deathSystemName.toLowerCase()} to ${escapeHtml(slot.game)}.<br>No valid future slot or no temp handicaps in the target game pool.`);
    }

    function markComplete(slotId) {
      const slot = challengeData.slots.find(s => s.id === slotId);
      if (!slot) return;
      slot.progress = 'Completed';

      let removedHandicapMessages = [];
      if (challengeData.disableAutomatedHandicapRemovals) {
        // Automated handicap removals are disabled, skip removal logic
        console.log("Automated handicap removals are disabled.");
      } else {
        // Remove 2-3 random permanent handicaps from any game
        const numHandicapsToRemove = Math.floor(Math.random() * 2) + 2; // 2 or 3
        let handicapsRemovedCount = 0;
        let availablePermHandicaps = [];
        for (const game in challengeData.permHandicaps) {
          challengeData.permHandicaps[game].forEach(h => availablePermHandicaps.push({ game, handicap: h }));
        }

        // Shuffle available handicaps to pick randomly
        for (let i = availablePermHandicaps.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [availablePermHandicaps[i], availablePermHandicaps[j]] = [availablePermHandicaps[j], availablePermHandicaps[i]];
        }

        while (handicapsRemovedCount < numHandicapsToRemove && availablePermHandicaps.length > 0) {
          const { game, handicap } = availablePermHandicaps.pop();
          // Remove from any slots that might have this handicap
          challengeData.slots.forEach(s => {
            if (s.game === game) {
              s.permanentHandicaps = s.permanentHandicaps.filter(h => h !== handicap);
            }
          });
          removedHandicapMessages.push(`Removed <strong>${escapeHtml(handicap)}</strong> from <strong>${escapeHtml(game)}</strong>`);
          handicapsRemovedCount++;
        }
      }

      renderGames();
      renderDatabase();
      saveData();
      let message = `Congratulations! You've completed ${escapeHtml(slot.game || 'this slot')}.<br>`;
      if (challengeData.disableAutomatedHandicapRemovals) {
        message += `Automated handicap removals are disabled in settings.`;
      } else if (removedHandicapMessages.length > 0) {
        message += `As a reward, the following permanent handicaps were removed:<br>${removedHandicapMessages.join('<br>')}`;
      } else {
        message += `No permanent handicaps were available to remove.`;
      }

      const allGamesCompleted = challengeData.slots.every(s => s.progress === 'Completed' || !s.game);
      if (allGamesCompleted) {
        message += '<br><br><strong>🎉 Congratulations! You\'ve completed all games in your rotation! 🎉</strong>';
        challengeData.totalCompletedRuns++; // Increment the new counter
        updateStats(); // Update stats display
      }

      showResult('Game Completed', message);
    }

    function clearSpecificHandicap(slotId, type, handicap) {
      const slot = challengeData.slots.find(s => s.id === slotId);
      if (!slot) return;

      const confirmRemoval = window.confirm(`Are you sure you want to remove the ${type} handicap "${handicap.split(' - ')[0]}" from ${slot.game}?`);
      if (!confirmRemoval) return;

      if (type === 'permanent') {
        slot.permanentHandicaps = slot.permanentHandicaps.filter(h => h !== handicap);
      } else {
        slot.temporaryHandicaps = slot.temporaryHandicaps.filter(h => h !== handicap);
      }
      renderGames();
      showResult('Handicap Removed', `Removed ${escapeHtml(type)} handicap from ${escapeHtml(slot.game || 'slot')}:<br><strong>${escapeHtml(handicap)}</strong>`);
    }

    // Rolls
    function rollTempHandicap() {
      if (challengeData.disableAutomatedHandicapGains) {
        showResult('Automated Gains Disabled', 'Automated temporary handicap gains are currently disabled in settings.');
        return;
      }
      // any slot with a game and not completed, excluding Slot 1
      const eligible = challengeData.slots.filter(s => s.game && s.progress !== 'Completed' && s.id !== 1);
      if (eligible.length === 0) {
        showResult('No Eligible Slots', 'No eligible slots found for temporary handicaps.');
        return;
      }
      const slot = eligible[Math.floor(Math.random() * eligible.length)];
      const pool = challengeData.tempHandicaps[slot.game] || [];
      if (pool.length === 0) {
        showResult('No Handicaps', `No temporary handicaps found for ${escapeHtml(slot.game)}.`);
        return;
      }
      const pick = pool[Math.floor(Math.random() * pool.length)];
      slot.temporaryHandicaps.push(pick);
      renderGames();
      showResult('Temporary Handicap', `Added to ${escapeHtml(slot.game)}:<br><strong>${escapeHtml(pick)}</strong>`);
    }

    function rollPermHandicap() {
      if (challengeData.disableAutomatedHandicapGains) {
        showResult('Automated Gains Disabled', 'Automated permanent handicap gains are currently disabled in settings.');
        return;
      }
      const eligible = challengeData.slots.filter(s => s.game && s.progress !== 'Completed');
      if (eligible.length === 0) {
        showResult('No Eligible Slots', 'No eligible slots found for permanent handicaps.');
        return;
      }
      const slot = eligible[Math.floor(Math.random() * eligible.length)];
      if (slot.permanentHandicaps.length >= 3) {
        showResult('Max Handicaps', `${escapeHtml(slot.game)} already has the maximum of 3 permanent handicaps.`);
        return;
      }
      const pool = challengeData.permHandicaps[slot.game] || [];
      if (pool.length === 0) {
        showResult('No Handicaps', `No permanent handicaps found for ${escapeHtml(slot.game)}.`);
        return;
      }
      const available = pool.filter(h => !slot.permanentHandicaps.includes(h));
      if (available.length === 0) {
        showResult('All Applied', `All available permanent handicaps have already been applied to ${escapeHtml(slot.game)}.`);
        return;
      }
      const pick = available[Math.floor(Math.random() * available.length)];
      slot.permanentHandicaps.push(pick);
      renderGames();
      showResult('Permanent Handicap', `Added to ${escapeHtml(slot.game)}:<br><strong>${escapeHtml(pick)}</strong>`);
    }

    function completeRotation() {
      let clearedAll = false;
      // Chance to clear permanent handicaps based on setting
      if (!challengeData.disableAutomatedHandicapRemovals) {
        if (Math.random() < challengeData.permClearChance) {
          challengeData.slots.forEach(s => s.permanentHandicaps = []);
          clearedAll = true;
        }
      } else {
        console.log("Automated permanent handicap clearing is disabled.");
      }

      // Clear temps, reset token usage, increment rotations
      challengeData.slots.forEach(s => s.temporaryHandicaps = []);
      challengeData.rotationsCompleted++;
      challengeData.tokenUsedThisRotation = false;

      let addedPermHandicapMessage = '';
      if (challengeData.disableAutomatedHandicapGains) {
        addedPermHandicapMessage = `<br>Automated permanent handicap gains are disabled in settings.`;
      } else {
        // Prepare a list of slots that are truly eligible to receive a new permanent handicap
        let trulyEligibleTargets = [];
        challengeData.slots.forEach(slot => {
          // A slot is eligible if it has a game, is not completed, and has less than 3 permanent handicaps
          if (slot.game && slot.progress !== 'Completed' && slot.permanentHandicaps.length < 3) {
            const permPool = challengeData.permHandicaps[slot.game] || [];
            // Filter the pool to find handicaps not already active on this slot
            const availablePerms = permPool.filter(h => !slot.permanentHandicaps.includes(h));

            // If there are any available and unapplied handicaps, this slot is a truly eligible target
            if (availablePerms.length > 0) {
              trulyEligibleTargets.push({ slot, availablePerms });
            }
          }
        });

        if (trulyEligibleTargets.length > 0) {
          // Pick a random truly eligible target
          const randomTargetIndex = Math.floor(Math.random() * trulyEligibleTargets.length);
          const { slot: targetSlot, availablePerms } = trulyEligibleTargets[randomTargetIndex];

          // Pick a random available handicap for that target slot
          const newPermHandicap = availablePerms[Math.floor(Math.random() * availablePerms.length)];
          targetSlot.permanentHandicaps.push(newPermHandicap);
          addedPermHandicapMessage = `<br>New permanent handicap added to ${escapeHtml(targetSlot.game)}:<br><strong>${escapeHtml(newPermHandicap)}</strong>`;
        } else {
          // This message only appears if NO slots are truly eligible across the entire rotation
          addedPermHandicapMessage = `<br>No active game slots could receive a new permanent handicap this rotation. All eligible games either have their maximum handicaps, or all available handicaps from their database pool are already active on them.`;
        }
      }

      // Stop timers
      challengeData.slots.forEach(s => { if (s.timerInterval) clearInterval(s.timerInterval); s.timerActive = false; });
      renderGames();
      updateTokenButton();

      let message = '';
      if (clearedAll) {
        message = 'All temporary handicaps cleared.<br>You got lucky and cleared all permanent handicaps too!';
      } else {
        message = 'All temporary handicaps have been cleared. Ready for next rotation!';
      }
      // Add automated handicap gains disabled message only if automated removals are NOT disabled and no perm handicap was added
      if (challengeData.disableAutomatedHandicapRemovals) {
        message += `<br>Automated permanent handicap removals are disabled in settings.`;
      }

      showResult('Rotation Complete', message + addedPermHandicapMessage);
    }

    function rollAchievement() {
      if (Math.random() < challengeData.tokenDropRate) {
        challengeData.tokens++;
        renderGames();
        updateTokenButton();
        showResult('Token Awarded!', 'Congratulations! You earned a token.<br>You can use it to clear one permanent handicap (max once per rotation).');
      } else {
        showResult('No Token', 'No token awarded this time. Keep going!');
      }
    }

    function useToken() {
      if (challengeData.tokens <= 0) {
        showResult('No Tokens', "You don't have any tokens to use.");
        return;
      }
      if (challengeData.tokenUsedThisRotation) {
        showResult('Token Already Used', 'You can only use one token per rotation.');
        return;
      }
      const withPH = challengeData.slots.filter(s => s.permanentHandicaps.length > 0);
      if (withPH.length === 0) {
        showResult('No Handicaps', 'There are no permanent handicaps to clear.');
        return;
      }
      const slot = withPH[Math.floor(Math.random() * withPH.length)];
      const pick = slot.permanentHandicaps[Math.floor(Math.random() * slot.permanentHandicaps.length)];
      slot.permanentHandicaps = slot.permanentHandicaps.filter(h => h !== pick);
      challengeData.tokens--;
      challengeData.tokenUsedThisRotation = true;
      renderGames();
      updateTokenButton();
      showResult('Token Used', `Cleared a permanent handicap from ${escapeHtml(slot.game)}:<br><strong>${escapeHtml(pick)}</strong>`);
    }

    // Timer
    function startTimer(slotId) {
      const slot = challengeData.slots.find(s => s.id === slotId);
      if (!slot || slot.timerActive) return;
      if (slot.timer <= 0) {
        showResult("Time's Up!", `Your 1-hour session for ${escapeHtml(slot.game || 'this slot')} has ended.`);
        return;
      }
      slot.timerActive = true;
      slot.timerInterval = setInterval(() => {
        slot.timer--; // Decrement timer
        if (slot.timer < 0) { // Check if timer has run out
          pauseTimer(slotId);
          showResult("Time's Up!", `Your 1-hour session for ${escapeHtml(slot.game || 'this slot')} has ended.`);
        }
        // Directly update the timer display for this slot
        const timerDisplayElement = document.querySelector(`#gameList > div[data-slot-id="${slot.id}"] .timer-display`);
        if (timerDisplayElement) {
          const timerMinutes = Math.floor(slot.timer / 60);
          const timerSeconds = slot.timer % 60;
          timerDisplayElement.textContent = `${timerMinutes.toString().padStart(2, '0')}:${timerSeconds.toString().padStart(2, '0')}`;
        }
        saveData();
      }, 1000);
      renderGames(); // Keep this to update button states etc.
    }

    function pauseTimer(slotId) {
      const slot = challengeData.slots.find(s => s.id === slotId);
      if (!slot || !slot.timerActive) return;
      slot.timerActive = false;
      clearInterval(slot.timerInterval);
      slot.timerInterval = null;
      // Directly update the timer display for this slot
      const timerDisplayElement = document.querySelector(`#gameList > div[data-slot-id="${slot.id}"] .timer-display`);
      if (timerDisplayElement) {
        const timerMinutes = Math.floor(slot.timer / 60);
        const timerSeconds = slot.timer % 60;
        timerDisplayElement.textContent = `${timerMinutes.toString().padStart(2, '0')}:${timerSeconds.toString().padStart(2, '0')}`;
      }
      renderGames(); // Keep this to update button states etc.
      saveData();
    }

    function resetTimer(slotId) {
      const slot = challengeData.slots.find(s => s.id === slotId);
      if (!slot) return;
      if (slot.timerInterval) clearInterval(slot.timerInterval);
      slot.timerActive = false;
      slot.timer = slot.sessionDuration; // Reset to custom duration
      slot.timerInterval = null;
      // Directly update the timer display for this slot immediately after reset
      const timerDisplayElement = document.querySelector(`#gameList > div[data-slot-id="${slot.id}"] .timer-display`);
      if (timerDisplayElement) {
        const timerMinutes = Math.floor(slot.timer / 60);
        const timerSeconds = slot.timer % 60;
        timerDisplayElement.textContent = `${timerMinutes.toString().padStart(2, '0')}:${timerSeconds.toString().padStart(2, '0')}`;
      }
      renderGames(); // Keep this to update button states etc.
      saveData();
    }

    function updateSessionDuration(slotId, durationMinutes) {
      const slot = challengeData.slots.find(s => s.id === slotId);
      if (slot) {
        const newDuration = parseInt(durationMinutes) * 60;
        if (!isNaN(newDuration) && newDuration > 0) {
          slot.sessionDuration = newDuration;
          // If timer is not active, reset it to the new duration
          if (!slot.timerActive) {
            slot.timer = newDuration;
            const timerDisplayElement = document.querySelector(`#gameList > div[data-slot-id="${slot.id}"] .timer-display`);
            if (timerDisplayElement) {
              const timerMinutes = Math.floor(slot.timer / 60);
              const timerSeconds = slot.timer % 60;
              timerDisplayElement.textContent = `${timerMinutes.toString().padStart(2, '0')}:${timerSeconds.toString().padStart(2, '0')}`;
            }
          }
          saveData();
        } else {
          slot.sessionDuration = 3600; // Default to 60 minutes if input is invalid or cleared
          if (!slot.timerActive) {
            slot.timer = 3600;
            const timerDisplayElement = document.querySelector(`#gameList > div[data-slot-id="${slot.id}"] .timer-display`);
            if (timerDisplayElement) {
              timerDisplayElement.textContent = `60:00`;
            }
          }
          saveData();
          // Optionally, visually reset the input field to 60
          document.getElementById(`duration-${slot.id}`).value = 60;
          alert('Invalid duration entered. Resetting to 60 minutes.');
        }
      }
    }

    // Database view
    function renderDatabase() {
      const dbList = document.getElementById('databaseList');
      dbList.innerHTML = '';

      // Get search input value
      const searchInput = document.getElementById('databaseSearchInput');
      const searchTerm = searchInput.value.toLowerCase();

      // Build sorted game list
      const games = [...challengeData.gameDatabase].sort((a,b) => a.localeCompare(b));

      // Filter games based on search term (contiguous substring match)
      const filteredGames = games.filter(game => {
        const lowerCaseGame = game.toLowerCase();

        // Create a regex for contiguous substring matching at word boundaries
        const regex = new RegExp(`\\b${searchTerm}`, 'i'); // '\\b' ensures word boundary

        if (searchTerm === '' || regex.test(lowerCaseGame)) return true; // Empty search term or regex match for game name

        // Check handicaps for contiguous substring match
        const permHandicaps = challengeData.permHandicaps[game] || [];
        const tempHandicaps = challengeData.tempHandicaps[game] || [];

        if (permHandicaps.some(h => regex.test(h))) return true;
        if (tempHandicaps.some(h => regex.test(h))) return true;

        return false;
      });

      if (filteredGames.length === 0) {
        dbList.innerHTML = `
          <div style="text-align: center; padding: 20px; border: 1px dashed #ddd; border-radius: 8px; background-color: #f9f9f9;">
            <p style="margin-bottom: 15px; color: #555;">No games found matching "<strong>${escapeHtml(searchInput.value)}</strong>".</p>
            <p style="font-size: 0.9em; color: #777; margin-bottom: 15px;">Adding a new game requires at least one handicap.</p>
            <button class="btn-primary" onclick="showAddHandicapModal('${escapeAttr(searchInput.value)}')">
              <i class="fas fa-plus"></i> Add "${escapeHtml(searchInput.value)}" as a new game
            </button>
          </div>
        `;
        return;
      }

      filteredGames.forEach(game => {
        const perm = challengeData.permHandicaps[game] || [];
        const temp = challengeData.tempHandicaps[game] || [];

        const el = document.createElement('div');
        el.className = 'database-game';
        el.innerHTML = `
          <div class="db-game-header">
            <h3 class="db-game-title">${escapeHtml(game)}</h3>
            <div class="db-game-actions">
              <button class="btn-primary btn-sm" onclick="showAddHandicapModal('${escapeAttr(game)}')"><i class="fas fa-plus"></i> Add Handicap</button>
              <button class="btn-warning btn-sm" onclick="showEditGameModal('${escapeAttr(game)}')"><i class="fas fa-edit"></i> Edit Game</button>
              <button class="btn-danger btn-sm" onclick="deleteGame('${escapeAttr(game)}')"><i class="fas fa-trash-alt"></i> Delete Game</button>
              <button class="btn-primary btn-sm" onclick="toggleHandicapList(this)"><i class="fas fa-minus"></i></button>
            </div>
          </div>
          <div class="handicap-list">
            <h4>Permanent Handicaps</h4>
            ${perm.length > 0
              ? perm.map(h => `
                  <div class="db-handicap permanent" data-game="${escapeAttr(game)}" data-type="permanent" data-handicap="${escapeAttr(h)}">
                    <span>${escapeHtml(h)}</span>
                    <div class="handicap-actions">
                      <button class="handicap-btn" title="Edit" onclick="showEditHandicapModal('${escapeAttr(game)}', 'permanent', '${escapeAttr(h)}')"><i class="fas fa-edit"></i></button>
                      <button class="handicap-btn" title="Delete" onclick="deleteHandicap('${escapeAttr(game)}', 'permanent', '${escapeAttr(h)}')"><i class="fas fa-times"></i></button>
                    </div>
                  </div>`)
              .join('')
              : '<p>No permanent handicaps</p>'}
            <h4>Temporary Handicaps</h4>
            ${temp.length > 0
              ? temp.map(h => `
                  <div class="db-handicap temporary" data-game="${escapeAttr(game)}" data-type="temporary" data-handicap="${escapeAttr(h)}">
                    <span>${escapeHtml(h)}</span>
                    <div class="handicap-actions">
                      <button class="handicap-btn" title="Edit" onclick="showEditHandicapModal('${escapeAttr(game)}', 'temporary', '${escapeAttr(h)}')"><i class="fas fa-edit"></i></button>
                      <button class="handicap-btn" title="Delete" onclick="deleteHandicap('${escapeAttr(game)}', 'temporary', '${escapeAttr(h)}')"><i class="fas fa-times"></i></button>
                    </div>
                  </div>`)
              .join('')
              : '<p>No temporary handicaps</p>'}
          </div>
        `;
        dbList.appendChild(el);
      });
    }

    function showAddHandicapModal(gameName = '') {
      const sel = document.getElementById('dbGameSelect');
      sel.innerHTML = '';
      const optNone = document.createElement('option');
      optNone.value = '';
      optNone.textContent = '-- Select existing game --';
      sel.appendChild(optNone);
      // sort for UX
      [...challengeData.gameDatabase].sort((a,b)=>a.localeCompare(b)).forEach(g => {
        const opt = document.createElement('option');
        opt.value = g;
        opt.textContent = g;
        sel.appendChild(opt);
      });
      document.getElementById('dbGameName').value = gameName || '';
      document.getElementById('handicapType').value = 'permanent';
      document.getElementById('handicapName').value = '';
      document.getElementById('handicapDescription').value = '';
      document.getElementById('bulkHandicaps').value = ''; // Clear bulk input
      document.getElementById('addHandicapModal').style.display = 'flex';
    }

    function addNewHandicap() {
      const gameSelect = document.getElementById('dbGameSelect').value.trim();
      const gameInput = document.getElementById('dbGameName').value.trim();
      const gameName = gameInput || gameSelect;
      const type = document.getElementById('handicapType').value;
      const name = document.getElementById('handicapName').value.trim();
      const description = document.getElementById('handicapDescription').value.trim();
      const bulkInput = document.getElementById('bulkHandicaps').value.trim();
      const handicapsToAdd = bulkInput.split('\n').map(h => h.trim()).filter(h => h);

      if (!gameName || !name) {
        alert('Please select or enter a game, and provide a handicap name.');
        return;
      }

      if (!challengeData.gameDatabase.includes(gameName)) {
        challengeData.gameDatabase.push(gameName);
      }
      if (!challengeData.permHandicaps[gameName]) challengeData.permHandicaps[gameName] = [];
      if (!challengeData.tempHandicaps[gameName]) challengeData.tempHandicaps[gameName] = [];

      const full = description ? `${name} - ${description}` : name;
      if (type === 'permanent') {
        challengeData.permHandicaps[gameName].push(full);
      } else {
        challengeData.tempHandicaps[gameName].push(full);
      }

      // Add bulk handicaps if any
      handicapsToAdd.forEach(h => {
        const [handicapName, handicapDesc] = h.split(' - ');
        const fullHandicap = handicapDesc ? `${handicapName} - ${handicapDesc}` : handicapName;
        if (type === 'permanent') {
          challengeData.permHandicaps[gameName].push(fullHandicap);
        } else {
          challengeData.tempHandicaps[gameName].push(fullHandicap);
        }
      });

      closeModal('addHandicapModal');
      renderDatabase();
      renderGames(); // updates dropdowns if new game
      saveData();
      showResult('Added to Database', `Added <strong>${escapeHtml(type)}</strong> handicap to <strong>${escapeHtml(gameName)}</strong>:<br><strong>${escapeHtml(full)}</strong>`);
    }

    function addBulkHandicaps() {
      const gameSelect = document.getElementById('dbGameSelect').value.trim();
      const gameInput = document.getElementById('dbGameName').value.trim();
      const gameName = gameInput || gameSelect;
      const type = document.getElementById('handicapType').value;
      const bulkText = document.getElementById('bulkHandicaps').value.trim();
      const handicaps = bulkText.split('\n').map(h => h.trim()).filter(h => h); // Split by newline, trim whitespace, filter out empty lines

      if (!gameName || handicaps.length === 0) {
        alert('Please select a game and enter at least one handicap.');
        return;
      }

      if (!challengeData.gameDatabase.includes(gameName)) {
        challengeData.gameDatabase.push(gameName);
      }
      if (!challengeData.permHandicaps[gameName]) challengeData.permHandicaps[gameName] = [];
      if (!challengeData.tempHandicaps[gameName]) challengeData.tempHandicaps[gameName] = [];

      const addedHandicaps = [];
      for (const h of handicaps) {
        const full = h; // No description for bulk add
        if (type === 'permanent') {
          if (!challengeData.permHandicaps[gameName].includes(full)) {
            challengeData.permHandicaps[gameName].push(full);
            addedHandicaps.push(`<strong>${escapeHtml(full)}</strong>`);
          }
        } else {
          if (!challengeData.tempHandicaps[gameName].includes(full)) {
            challengeData.tempHandicaps[gameName].push(full);
            addedHandicaps.push(`<strong>${escapeHtml(full)}</strong>`);
          }
        }
      }

      closeModal('addHandicapModal');
      renderDatabase();
      renderGames(); // updates dropdowns and slot handicaps
      saveData();
      showResult('Handicaps Added', `Added ${addedHandicaps.length} handicaps to <strong>${escapeHtml(gameName)}</strong>:<br>${addedHandicaps.join('<br>')}`);
    }

    // Edit Handicap
    function showEditHandicapModal(gameName, type, handicap) {
      // Store original values
      document.getElementById('originalEditGameName').value = gameName;
      document.getElementById('originalEditHandicapType').value = type;
      document.getElementById('originalEditHandicap').value = handicap;

      const sel = document.getElementById('editGameSelect');
      sel.innerHTML = '';
      const optNone = document.createElement('option');
      optNone.value = '';
      optNone.textContent = '-- Select existing game --';
      sel.appendChild(optNone);
      // sort for UX
      [...challengeData.gameDatabase].sort((a,b)=>a.localeCompare(b)).forEach(g => {
        const opt = document.createElement('option');
        opt.value = g;
        opt.textContent = g;
        sel.appendChild(opt);
      });
      document.getElementById('editGameSelect').value = gameName; // Select the current game
      document.getElementById('editGameName').value = gameName;
      document.getElementById('editHandicapType').value = type;
      const parts = handicap.split(' - ');
      document.getElementById('editHandicapName').value = parts[0];
      document.getElementById('editHandicapDescription').value = parts.length > 1 ? parts.slice(1).join(' - ') : '';
      document.getElementById('editHandicapModal').style.display = 'flex';
    }

    function saveEditedHandicap() {
      const originalGameName = document.getElementById('originalEditGameName').value;
      const originalHandicapType = document.getElementById('originalEditHandicapType').value;
      const originalHandicap = document.getElementById('originalEditHandicap').value;

      const newGameSelect = document.getElementById('editGameSelect').value.trim();
      const newGameInput = document.getElementById('editGameName').value.trim();
      const newGameName = newGameInput || newGameSelect;
      const newHandicapType = document.getElementById('editHandicapType').value;
      const newHandicapName = document.getElementById('editHandicapName').value.trim();
      const newHandicapDescription = document.getElementById('editHandicapDescription').value.trim();

      if (!newGameName || !newHandicapName) {
        alert('Please select or enter a game, and provide a handicap name.');
        return;
      }

      const newFullHandicap = newHandicapDescription ? `${newHandicapName} - ${newHandicapDescription}` : newHandicapName;

      // Remove old handicap
      if (originalHandicapType === 'permanent') {
        challengeData.permHandicaps[originalGameName] = challengeData.permHandicaps[originalGameName].filter(h => h !== originalHandicap);
      } else {
        challengeData.tempHandicaps[originalGameName] = challengeData.tempHandicaps[originalGameName].filter(h => h !== originalHandicap);
      }

      // Add new game to database if it doesn't exist
      if (!challengeData.gameDatabase.includes(newGameName)) {
        challengeData.gameDatabase.push(newGameName);
      }
      if (!challengeData.permHandicaps[newGameName]) challengeData.permHandicaps[newGameName] = [];
      if (!challengeData.tempHandicaps[newGameName]) challengeData.tempHandicaps[newGameName] = [];

      // Add new handicap
      if (newHandicapType === 'permanent') {
        // Avoid duplicates in the new game's pool
        if (!challengeData.permHandicaps[newGameName].includes(newFullHandicap)) {
          challengeData.permHandicaps[newGameName].push(newFullHandicap);
        }
      } else {
        // Avoid duplicates in the new game's pool
        if (!challengeData.tempHandicaps[newGameName].includes(newFullHandicap)) {
          challengeData.tempHandicaps[newGameName].push(newFullHandicap);
        }
      }

      closeModal('editHandicapModal');
      renderDatabase();
      renderGames(); // updates dropdowns and slot handicaps
      saveData();
      showResult('Handicap Updated', `Updated <strong>${escapeHtml(newHandicapType)}</strong> handicap for <strong>${escapeHtml(newGameName)}</strong>:<br><strong>${escapeHtml(newFullHandicap)}</strong>`);
    }

    // Delete Handicap
    function deleteHandicap(gameName, type, handicap) {
      const confirm = window.confirm(`Are you sure you want to delete the "${escapeHtml(handicap.split(' - ')[0])}" handicap from ${escapeHtml(gameName)}? This action cannot be undone.`);
      if (!confirm) return;

      if (type === 'permanent') {
        challengeData.permHandicaps[gameName] = challengeData.permHandicaps[gameName].filter(h => h !== handicap);
      } else {
        challengeData.tempHandicaps[gameName] = challengeData.tempHandicaps[gameName].filter(h => h !== handicap);
      }

      // Also remove from any slots that might have this handicap
      challengeData.slots.forEach(slot => {
        if (slot.game === gameName) {
          if (type === 'permanent') {
            slot.permanentHandicaps = slot.permanentHandicaps.filter(h => h !== handicap);
          } else {
            slot.temporaryHandicaps = slot.temporaryHandicaps.filter(h => h !== handicap);
          }
        }
      });

      closeModal('editHandicapModal'); // Close edit modal if open
      renderDatabase();
      renderGames(); // updates dropdowns if new game
      saveData();
      showResult('Handicap Deleted', `Deleted <strong>${escapeHtml(type)}</strong> handicap from <strong>${escapeHtml(gameName)}</strong>:<br><strong>${escapeHtml(handicap)}</strong>`);
    }

    // Reset progress (not database)
    function showResetModal() {
      document.getElementById('resetModal').style.display = 'flex';
    }

    function resetProgress() {
      const confirmTimerReset = window.confirm('Do you also want to reset all timers to their default 60-minute duration?');

      challengeData.slots.forEach(s => {
        s.progress = "Not Started";
        s.deaths = 0;
        s.permanentHandicaps = [];
        s.temporaryHandicaps = [];
        if (s.timerInterval) clearInterval(s.timerInterval);
        s.timerInterval = null;
        s.timerActive = false;
        if (confirmTimerReset) {
          s.timer = 3600; // Reset to 60 minutes
          s.sessionDuration = 3600; // Reset session duration as well
        } else {
          s.timer = s.sessionDuration; // Retain custom duration but reset timer to it
        }
      });
      challengeData.rotationsCompleted = 0;
      challengeData.tokens = 0;
      challengeData.tokenUsedThisRotation = false;

      closeModal('resetModal');
      renderGames();
      updateTokenButton();
      showResult('Progress Reset', 'All progress has been reset. Slots, selected games, and the database remain intact.');
    }

    // Function to clear total completed runs
    function clearTotalCompletedRuns() {
      const confirmClear = window.confirm('Are you sure you want to clear the Total Completed Runs counter? This cannot be undone.');
      if (confirmClear) {
        challengeData.totalCompletedRuns = 0;
        updateStats();
        saveData();
        showResult('Counter Cleared', 'Total Completed Runs counter has been reset to 0.');
      }
    }

    // Generic function to update settings
    function updateSetting(key, value) {
      challengeData[key] = value;
      saveData();
      renderSettings(); // Re-render settings to reflect potential changes (e.g., checkbox state)
    }

    // Render settings page
    function renderSettings() {
      document.getElementById('tokenDropRateInput').value = (challengeData.tokenDropRate * 100).toFixed(0);
      document.getElementById('permClearChanceInput').value = (challengeData.permClearChance * 100).toFixed(0);
      document.getElementById('manualHandicapsToggle').checked = challengeData.manualHandicapsEnabled;
      document.getElementById('deathSystemNameInput').value = challengeData.deathSystemName;
      document.getElementById('disableAutomatedHandicapGainsToggle').checked = challengeData.disableAutomatedHandicapGains;
      document.getElementById('disableAutomatedHandicapRemovalsToggle').checked = challengeData.disableAutomatedHandicapRemovals;
      // Additional settings can be added here
    }

    // Modular Rules Page Toggle
    function toggleRulesPageMode() {
      const rulesContent = document.getElementById('rulesContent');
      const settingsContent = document.getElementById('settingsContent');
      const rulesPageTitle = document.getElementById('rulesPageTitle');
      const toggleButtonText = document.getElementById('rulesPageToggleButtonText');
      const toggleButtonIcon = document.querySelector('#rules-tab .section-header button i');

      if (rulesContent.style.display !== 'none') {
        // Switch to settings view
        rulesContent.style.display = 'none';
        settingsContent.style.display = 'block';
        rulesPageTitle.textContent = 'Reroll Challenge Settings';
        toggleButtonText.textContent = 'Show Rules';
        toggleButtonIcon.classList.remove('fa-cog');
        toggleButtonIcon.classList.add('fa-book'); // Change icon to a book for rules
        renderSettings(); // Render settings when switching to settings view
      } else {
        // Switch back to rules view
        rulesContent.style.display = 'block';
        settingsContent.style.display = 'none';
        rulesPageTitle.textContent = 'Reroll Challenge rules';
        toggleButtonText.textContent = 'Show Settings';
        toggleButtonIcon.classList.remove('fa-book');
        toggleButtonIcon.classList.add('fa-cog'); // Change icon back to cog for settings
      }
    }

    // Game Edit/Delete
    function showEditGameModal(gameName) {
      document.getElementById('originalGameName').value = gameName;
      document.getElementById('editedGameName').value = gameName;
      document.getElementById('editGameModal').style.display = 'flex';
    }

    function saveEditedGame() {
      const originalGameName = document.getElementById('originalGameName').value;
      const newGameName = document.getElementById('editedGameName').value.trim();

      if (!newGameName) {
        alert('Game name cannot be empty.');
        return;
      }
      if (newGameName === originalGameName) {
        closeModal('editGameModal');
        return;
      }
      if (challengeData.gameDatabase.includes(newGameName)) {
        alert('A game with this name already exists.');
        return;
      }

      // Update game name in gameDatabase
      const index = challengeData.gameDatabase.indexOf(originalGameName);
      if (index > -1) {
        challengeData.gameDatabase[index] = newGameName;
      }

      // Update handicaps tied to the game
      challengeData.permHandicaps[newGameName] = challengeData.permHandicaps[originalGameName] || [];
      delete challengeData.permHandicaps[originalGameName];
      challengeData.tempHandicaps[newGameName] = challengeData.tempHandicaps[originalGameName] || [];
      delete challengeData.tempHandicaps[originalGameName];

      // Update slots that use this game
      challengeData.slots.forEach(slot => {
        if (slot.game === originalGameName) {
          slot.game = newGameName;
        }
      });

      closeModal('editGameModal');
      renderDatabase();
      renderGames(); // Update game dropdowns
      saveData();
      showResult('Game Renamed', `Game <strong>${escapeHtml(originalGameName)}</strong> renamed to <strong>${escapeHtml(newGameName)}</strong>.`);
    }

    function deleteGame(gameName) {
      const confirm = window.confirm(`Are you sure you want to delete the game "${escapeHtml(gameName)}" and all its associated handicaps? This action cannot be undone.`);
      if (!confirm) return;

      // Remove from gameDatabase
      challengeData.gameDatabase = challengeData.gameDatabase.filter(g => g !== gameName);

      // Remove handicaps
      delete challengeData.permHandicaps[gameName];
      delete challengeData.tempHandicaps[gameName];

      // Clear game from any slots that use it
      challengeData.slots.forEach(slot => {
        if (slot.game === gameName) {
          slot.game = '';
          slot.permanentHandicaps = [];
          slot.temporaryHandicaps = [];
        }
      });

      renderDatabase();
      renderGames(); // Update dropdowns and slots
      saveData();
      showResult('Game Deleted', `Game <strong>${escapeHtml(gameName)}</strong> and all its handicaps have been deleted.`);
    }

    function toggleHandicapList(button) {
      const handicapList = button.closest('.database-game').querySelector('.handicap-list');
      if (handicapList) {
        handicapList.classList.toggle('hidden');
        const icon = button.querySelector('i');
        if (handicapList.classList.contains('hidden')) {
          icon.classList.remove('fa-minus');
          icon.classList.add('fa-plus');
        } else {
          icon.classList.remove('fa-plus');
          icon.classList.add('fa-minus');
        }
      }
    }

    // Export / Import
    function showExportModal() {
      const exportData = btoa(unescape(encodeURIComponent(JSON.stringify(challengeData))));
      document.getElementById('exportData').value = exportData;
      document.getElementById('exportModal').style.display = 'flex';
    }

    function copyExportData() {
      const ta = document.getElementById('exportData');
      ta.select();
      ta.setSelectionRange(0, 999999);
      document.execCommand('copy');
      showResult('Copied', 'Export seed copied to clipboard.');
    }

    function showImportModal() {
      document.getElementById('importData').value = '';
      document.getElementById('importModal').style.display = 'flex';
    }

    function importChallengeData() {
      const seed = document.getElementById('importData').value.trim();
      if (!seed) {
        alert('Please paste a seed to import.');
        return;
      }
      try {
        const decoded = JSON.parse(decodeURIComponent(escape(atob(seed))));
        // validate minimally
        if (!decoded || typeof decoded !== 'object' || !Array.isArray(decoded.slots)) throw new Error('Invalid seed');
        // stop timers
        if (challengeData.slots) {
          challengeData.slots.forEach(s => { if (s.timerInterval) clearInterval(s.timerInterval); });
        }
        challengeData = decoded;
        // sanitize timers
        challengeData.slots.forEach(s => { s.timerInterval = null; s.timerActive = false; s.timer = s.timer || 0; });

        closeModal('importModal');
        renderGames();
        renderDatabase();
        updateTokenButton();
        saveData();
        showResult('Data Imported', 'Your challenge data has been successfully imported.');
      } catch (e) {
        console.error('Import error', e);
        alert('Invalid seed. Please check your input and try again.');
      }
    }

    // Modals / UI helpers
    function showResult(title, content) {
      document.getElementById('resultTitle').textContent = title;
      document.getElementById('resultContent').innerHTML = content;
      document.getElementById('resultModal').style.display = 'flex';
    }

    function closeModal(id) {
      document.getElementById(id).style.display = 'none';
    }

    function escapeHtml(str) {
      return String(str)
        .replace(/&/g,'&amp;')
        .replace(/</g,'&lt;')
        .replace(/>/g,'&gt;')
        .replace(/"/g,'&quot;')
        .replace(/'/g,'&#39;');
    }
    function escapeAttr(str) {
      return String(str).replace(/'/g, '&#39;').replace(/"/g, '&quot;');
    }

    // Searchable Dropdown Logic
    function renderSearchableDropdown(inputElement, slotId) {
      const searchTerm = inputElement.value.toLowerCase();
      const resultsContainer = inputElement.nextElementSibling; // The div with class 'searchable-dropdown-results'
      const dropdownContainer = inputElement.closest('.searchable-dropdown');
      const gameCard = inputElement.closest('.game-card'); // Get the parent game-card

      resultsContainer.innerHTML = '';

      if (searchTerm === '') {
        // Show all games if search term is empty
        challengeData.gameDatabase.sort((a, b) => a.localeCompare(b)).forEach(game => {
          const item = document.createElement('div');
          item.className = 'searchable-dropdown-item';
          item.textContent = game;
          item.onmousedown = (e) => { // Use mousedown to prevent blur from firing before click
            e.preventDefault();
            inputElement.value = game;
            updateGame(slotId, game);
            resultsContainer.style.display = 'none';
            dropdownContainer.classList.remove('active');
            if (gameCard) gameCard.classList.remove('active-dropdown'); // Remove active class
          };
          resultsContainer.appendChild(item);
        });
      } else {
        // Filter games based on search term
        const regex = new RegExp(`\\b${searchTerm}`, 'i');
        challengeData.gameDatabase.filter(game => regex.test(game)).sort((a,b) => a.localeCompare(b)).forEach(game => {
          const item = document.createElement('div');
          item.className = 'searchable-dropdown-item';
          item.textContent = game;
          item.onmousedown = (e) => {
            e.preventDefault();
            inputElement.value = game;
            updateGame(slotId, game);
            resultsContainer.style.display = 'none';
            dropdownContainer.classList.remove('active');
            if (gameCard) gameCard.classList.remove('active-dropdown'); // Remove active class
          };
          resultsContainer.appendChild(item);
        });
      }

      resultsContainer.style.display = 'block';
      dropdownContainer.classList.add('active');
      if (gameCard) gameCard.classList.add('active-dropdown'); // Add active class to game card
    }

    function hideSearchableDropdown(inputElement) {
      const resultsContainer = inputElement.nextElementSibling;
      const dropdownContainer = inputElement.closest('.searchable-dropdown');
      const gameCard = inputElement.closest('.game-card'); // Get the parent game-card

      // Delay hiding to allow click on results item
      setTimeout(() => {
        if (!resultsContainer.contains(document.activeElement)) {
          resultsContainer.style.display = 'none';
          dropdownContainer.classList.remove('active');
          if (gameCard) gameCard.classList.remove('active-dropdown'); // Remove active class
        }
      }, 150);
    }

    // Manual Assign Handicap Functions
    function showManualAssignHandicapModal(slotId) {
      const slot = challengeData.slots.find(s => s.id === slotId);
      if (!slot || !slot.game) {
        showResult('No Game Selected', 'Please select a game for this slot before manually assigning handicaps.');
        return;
      }

      document.getElementById('manualAssignSlotId').value = slotId;
      document.getElementById('manualAssignGameName').value = slot.game;
      document.getElementById('manualAssignHandicapType').value = 'permanent'; // Default to permanent

      populateManualHandicaps(); // Populate dropdown based on initial type

      document.getElementById('manualAssignHandicapModal').style.display = 'flex';
    }

    function populateManualHandicaps() {
      const slotId = parseInt(document.getElementById('manualAssignSlotId').value);
      const slot = challengeData.slots.find(s => s.id === slotId);
      if (!slot) return;

      const gameName = slot.game;
      const type = document.getElementById('manualAssignHandicapType').value;
      const handicapSelect = document.getElementById('manualAssignHandicap');
      handicapSelect.innerHTML = '<option value="">-- Select a handicap --</option>';

      const pool = type === 'permanent' ? (challengeData.permHandicaps[gameName] || []) : (challengeData.tempHandicaps[gameName] || []);
      const currentHandicaps = type === 'permanent' ? slot.permanentHandicaps : slot.temporaryHandicaps;

      const availableHandicaps = pool.filter(h => !currentHandicaps.includes(h));

      availableHandicaps.forEach(h => {
        const option = document.createElement('option');
        option.value = h;
        option.textContent = h;
        handicapSelect.appendChild(option);
      });
    }

    function assignManualHandicap() {
      const slotId = parseInt(document.getElementById('manualAssignSlotId').value);
      const type = document.getElementById('manualAssignHandicapType').value;
      const selectedHandicap = document.getElementById('manualAssignHandicap').value;

      if (!selectedHandicap) {
        alert('Please select a handicap to assign.');
        return;
      }

      const slot = challengeData.slots.find(s => s.id === slotId);
      if (!slot) return;

      let targetHandicapArray;
      if (type === 'permanent') {
        targetHandicapArray = slot.permanentHandicaps;
      } else {
        targetHandicapArray = slot.temporaryHandicaps;
      }

      if (targetHandicapArray.includes(selectedHandicap)) {
        showResult('Handicap Already Assigned', `The ${type} handicap <strong>${escapeHtml(selectedHandicap)}</strong> is already assigned to ${escapeHtml(slot.game)}.`);
      } else {
        targetHandicapArray.push(selectedHandicap);
        showResult('Handicap Assigned', `Manually assigned ${type} handicap to ${escapeHtml(slot.game)}:<br><strong>${escapeHtml(selectedHandicap)}</strong>`);
      }

      closeModal('manualAssignHandicapModal');
      renderGames();
      saveData();
    }

    // Refresh UI function
    function refreshUI() {
      renderGames();
      updateStats();
      updateTokenButton();
      renderDatabase();
      renderSettings();
      showResult('UI Refreshed', 'All UI elements have been reloaded.');
    }

    document.addEventListener('DOMContentLoaded', init);
  </script>
</body>
</html>

