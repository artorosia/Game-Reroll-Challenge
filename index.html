<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Reroll Challenge</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"/>
  <style>
    :root {
      --primary: #2c3e50;
      --secondary: #3498db;
      --accent: #e74c3c;
      --light: #ecf0f1;
      --dark: #2c3e50;
      --success: #2ecc71;
      --warning: #f39c12;
      --purple: #9b59b6;
      --gray: #95a5a6;
    }

    * { box-sizing: border-box; margin: 0; padding: 0; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
    body { background-color: #f5f7fa; color: var(--dark); line-height: 1.6; }
    .container { max-width: 1400px; margin: 0 auto; padding: 20px; }

    header {
      background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
      color: white; padding: 25px; border-radius: 12px; margin-bottom: 25px; text-align: center;
      box-shadow: 0 6px 12px rgba(0,0,0,0.15);
      position: relative; /* Added for absolute positioning of children */
    }
    h1 { margin-bottom: 10px; font-size: 2.5rem; }
    .subtitle { font-style: italic; opacity: 0.9; font-size: 1.1rem; }

    .tabs {
      display: flex; margin-bottom: 20px; background: white; border-radius: 12px; overflow: hidden;
      box-shadow: 0 4px 10px rgba(0,0,0,0.1);
    }
    .tab {
      padding: 15px 20px; cursor: pointer; font-weight: 500; transition: background-color 0.2s; flex: 1; text-align: center;
    }
    .tab:not(.active):hover { background-color: #f8f9fa; }
    .tab.active { background-color: var(--secondary); color: white; }
    .tab-content { display: none; }
    .tab-content.active { display: block; }

    .dashboard { display: grid; grid-template-columns: 1fr 350px; gap: 25px; }
    .games-container { background: white; border-radius: 12px; box-shadow: 0 4px 10px rgba(0,0,0,0.1); padding: 25px; }
    .section-header {
      display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; padding-bottom: 15px; border-bottom: 2px solid var(--light);
    }
    .game-list { display: flex; flex-direction: column; gap: 20px; }
    .game-card {
      border: 1px solid #e0e0e0; border-radius: 10px; padding: 20px; background: white; transition: transform 0.2s, box-shadow 0.2s; position: relative;
    }
    .game-card:hover { transform: translateY(-5px); box-shadow: 0 8px 16px rgba(0,0,0,0.1); }
    .game-card.active-dropdown { z-index: 102; } /* Ensure active card is above siblings */
    .game-card.completed { background-color: #e6ffe6; border-color: var(--success); }
    .game-card.completed .game-title { color: var(--success); }
    .game-card.dragging { opacity: 0.5; border: 2px dashed var(--secondary); }
    .game-card.drag-over { border: 2px solid var(--secondary); }
    .game-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
      padding-right: 30px; /* Add padding to make space for the delete button */
    }
    .game-delete-btn {
      position: absolute;
      top: 0;
      right: 0;
      width: 40px; /* Adjust size as needed */
      height: 40px; /* Adjust size as needed */
      background: rgba(231, 76, 60, 0.1); /* Faded red */
      border: none;
      border-bottom-left-radius: 100%; /* Quarter circle for top-right */
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 1.2em;
      color: transparent; /* Make icon invisible by default */
      cursor: pointer;
      opacity: 1; /* Keep opacity at 1, will fade with background color */
      transition: all 0.2s ease-in-out;
      z-index: 10; /* Ensure it's above other elements */
    }
    .game-delete-btn:hover {
      opacity: 1;
      background-color: var(--accent); /* Vibrant red on hover */
      color: white; /* White icon on hover */
    }
    .game-title { font-weight: bold; font-size: 1.1em; color: var(--primary); display: flex; align-items: center; gap: 10px; }
    .game-title select { padding: 6px 8px; border-radius: 6px; border: 1px solid #ddd; }
    .game-progress { font-size: 0.95em; color: #666; display: flex; gap: 15px; }
    /* Styles for searchable dropdown */
    .searchable-dropdown { position: relative; width: 250px; }
    .searchable-dropdown input { width: 100%; padding: 6px 8px; border-radius: 6px; border: 1px solid #ddd; font-size: 0.95em; }
    .searchable-dropdown-results { position: absolute; top: 100%; left: 0; right: 0; background: white; border: 1px solid #ddd; border-radius: 6px; max-height: 200px; overflow-y: auto; z-index: 100; box-shadow: 0 4px 8px rgba(0,0,0,0.1); }
    .searchable-dropdown-item { padding: 6px 8px; cursor: pointer; font-size: 0.9em; }
    .searchable-dropdown-item:hover { background-color: #f0f0f0; }
    .searchable-dropdown.active { z-index: 101; } /* Ensure active dropdown is above other cards */

    .game-details { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 15px; }
    .handicap-section strong { display: block; margin-bottom: 6px; }
    .handicap {
      background: #f8f9fa; padding: 10px; border-radius: 6px; font-size: 0.9em; margin-bottom: 8px;
      display: flex; justify-content: space-between; align-items: center;
    }
    .handicap.permanent { border-left: 4px solid var(--accent); }
    .handicap.temporary { border-left: 4px solid var(--secondary); }
    .handicap-actions { display: flex; gap: 8px; }
    .handicap-btn { background: none; border: none; cursor: pointer; font-size: 0.9em; color: var(--gray); }
    .handicap-btn:hover { color: var(--accent); }

    .timer-widget {
      display: flex; align-items: center; gap: 10px; margin-top: 10px; padding: 10px; background: #f8f9fa; border-radius: 6px;
    }
    .timer-display { font-family: monospace; font-size: 1.2em; font-weight: bold; }
    .timer-btn { padding: 6px 10px; font-size: 0.9em; }

    .controls { display: flex; gap: 12px; margin-top: 15px; flex-wrap: wrap; }
    button {
      padding: 10px 15px; border: none; border-radius: 6px; cursor: pointer; font-weight: 500; transition: all 0.2s;
      display: inline-flex; align-items: center; gap: 6px;
    }
    .btn-primary { background-color: var(--secondary); color: white; }
    .btn-primary:hover { background-color: #2980b9; transform: translateY(-2px); }
    .btn-danger { background-color: var(--accent); color: white; }
    .btn-danger:hover { background-color: #c0392b; transform: translateY(-2px); }
    .btn-success { background-color: var(--success); color: white; }
    .btn-success:hover { background-color: #27ae60; transform: translateY(-2px); }
    .btn-warning { background-color: var(--warning); color: white; }
    .btn-warning:hover { background-color: #e67e22; transform: translateY(-2px); }
    .btn-purple { background-color: var(--purple); color: white; }
    .btn-purple:hover { background-color: #8e44ad; transform: translateY(-2px); }
    .btn-gray { background-color: #bdc3c7; color: white; cursor: default; }

    /* Rarity Colors (Diablo-like) */
    .rarity-common { color: var(--gray); /* White/Light Gray */ }
    .rarity-uncommon { color: var(--success); /* Green */ }
    .rarity-rare { color: var(--secondary); /* Blue */ }
    .rarity-legendary { color: var(--purple); /* Purple */ }
    .rarity-mythic { color: var(--warning); /* Orange */ }

    .sidebar { display: flex; flex-direction: column; gap: 25px; }
    .panel { background: white; border-radius: 12px; box-shadow: 0 4px 10px rgba(0,0,0,0.1); padding: 20px; }
    .panel h3 { margin-bottom: 15px; padding-bottom: 10px; border-bottom: 2px solid var(--light); color: var(--primary); }

    .action-buttons { display: flex; flex-direction: column; gap: 12px; }
    .action-button { width: 100%; text-align: left; padding: 12px; justify-content: flex-start; }

    .stats { background: #f8f9fa; padding: 15px; border-radius: 8px; }
    .stat-item {
      display: flex; justify-content: space-between; margin-bottom: 10px; padding-bottom: 8px; border-bottom: 1px solid #e0e0e0;
    }
    .stat-item:last-child { border-bottom: none; margin-bottom: 0; padding-bottom: 0; }

    .token-counter {
      display: flex; align-items: center; justify-content: center; gap: 10px; font-size: 1.2em; margin: 15px 0;
    }
    .token-icon { color: var(--warning); font-size: 1.5em; }
    .token-value { font-weight: bold; font-size: 1.3em; }

    footer {
      text-align: center; margin-top: 40px; padding: 25px; color: #7f8c8d; font-size: 0.95em; background: white; border-radius: 12px;
      box-shadow: 0 4px 10px rgba(0,0,0,0.1);
    }

    .dark-mode-toggle {
      background: none; border: none; font-size: 1.5em; cursor: pointer; color: white; position: absolute; top: 30px; right: 30px;
      transition: color 0.3s;
    }
    .dark-mode-toggle:hover {
      color: var(--light);
    }

    /* Dark Mode Styles */
    body.dark-mode {
      --primary: #82a8cf;
      --secondary: #5a9bd4;
      --accent: #e06c75;
      --light: #3b4252;
      --dark: #eceff4;
      --success: #67b867;
      --warning: #e5c07b;
      --purple: #c678dd;
      --gray: #9baec8;

      background-color: #282c34;
      color: var(--dark);
    }

    body.dark-mode header {
      background: linear-gradient(135deg, #3b4252 0%, #5a9bd4 100%);
      box-shadow: 0 6px 12px rgba(0,0,0,0.3);
    }

    body.dark-mode .tabs, body.dark-mode .games-container, body.dark-mode .panel, body.dark-mode footer {
      background: #21252b;
      box-shadow: 0 4px 10px rgba(0,0,0,0.3);
    }

    body.dark-mode .tab:not(.active):hover {
      background-color: #3b4252;
    }

    body.dark-mode .tab.active {
      background-color: var(--secondary);
    }

    body.dark-mode .game-card {
      border: 1px solid #3b4252;
      background: #2c313a;
    }

    body.dark-mode .game-card:hover {
      box-shadow: 0 8px 16px rgba(0,0,0,0.3);
    }

    body.dark-mode .game-card.completed {
      background-color: #3b4252;
      border-color: var(--success);
    }

    body.dark-mode .game-title {
      color: var(--dark);
    }

    body.dark-mode .game-progress {
      color: var(--gray);
    }

    body.dark-mode .searchable-dropdown input {
      background: #3b4252;
      border-color: #4b5263;
      color: var(--dark);
    }

    body.dark-mode .searchable-dropdown-results {
      background: #21252b;
      border-color: #4b5263;
    }

    body.dark-mode .searchable-dropdown-item:hover {
      background-color: #3b4252;
    }

    body.dark-mode .handicap {
      background: #3b4252;
      border-color: #4b5263;
    }

    body.dark-mode .handicap-btn {
      color: var(--gray);
    }

    body.dark-mode .timer-widget {
      background: #3b4252;
    }

    body.dark-mode .section-header, body.dark-mode .panel h3 {
      border-bottom-color: #4b5263;
      color: var(--dark);
    }

    body.dark-mode .stat-item {
      border-bottom-color: #4b5263;
    }

    body.dark-mode hr {
      border-top-color: #4b5263;
    }

    body.dark-mode .modal-content {
      background: #21252b;
      box-shadow: 0 10px 25px rgba(0,0,0,0.4);
    }

    body.dark-mode .modal-header {
      border-bottom-color: #4b5263;
    }

    body.dark-mode .close {
      color: var(--gray);
    }
    body.dark-mode .close:hover {
      color: var(--dark);
    }

    body.dark-mode .form-group input, body.dark-mode .form-group select, body.dark-mode .form-group textarea {
      background: #3b4252;
      border-color: #4b5263;
      color: var(--dark);
    }

    body.dark-mode .db-handicap {
      background: #3b4252;
    }

    body.dark-mode .db-game-title {
      color: var(--dark);
    }

    body.dark-mode .form-group p.hint {
      color: var(--gray);
    }

    body.dark-mode #rulesContent h3 {
      color: var(--dark);
    }

    body.dark-mode #rulesContent p, body.dark-mode #rulesContent li {
      color: var(--dark);
    }

    body.dark-mode .token-counter .token-icon {
      color: var(--warning);
    }

    body.dark-mode .stats {
      background: #3b4252;
      color: var(--dark);
    }

    body.dark-mode .database-list > div {
      background-color: #2c313a !important;
      border: 1px dashed #4b5263 !important;
    }

    body.dark-mode .database-list > div p {
      color: var(--gray) !important;
    }

    .database-list { max-height: 500px; overflow-y: auto; }
    .database-game { margin-bottom: 20px; padding-bottom: 15px; border-bottom: 1px solid #eee; }
    .database-game:last-child { border-bottom: none; }
    .handicap-list { margin-left: 20px; }
    .db-handicap { background: #f8f9fa; padding: 8px 10px; border-radius: 6px; margin: 6px 0; display: flex; justify-content: space-between; align-items: center; }
    .db-handicap.permanent { border-left: 4px solid var(--accent); }
    .db-handicap.temporary { border-left: 4px solid var(--secondary); }
    .db-game-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
    .db-game-title { font-weight: bold; font-size: 1.1em; color: var(--primary); }
    .db-game-actions { display: flex; gap: 8px; }
    .handicap-list.hidden { display: none; }

    .modal {
      display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background-color: rgba(0,0,0,0.5); z-index: 1000; justify-content: center; align-items: center;
    }
    .modal-content {
      background: white; padding: 30px; border-radius: 12px; width: 90%; max-width: 700px; max-height: 80vh; overflow-y: auto;
      box-shadow: 0 10px 25px rgba(0,0,0,0.2);
    }
    .modal-header {
      display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; padding-bottom: 15px; border-bottom: 2px solid var(--light);
    }
    .close { font-size: 1.8em; cursor: pointer; color: var(--gray); }
    .close:hover { color: var(--dark); }

    .form-group { margin-bottom: 16px; }
    .form-group label { display: block; margin-bottom: 8px; font-weight: 500; }
    .form-group input, .form-group select, .form-group textarea {
      width: 100%; padding: 12px; border: 1px solid #ddd; border-radius: 6px; font-size: 1em;
    }
    .form-group.min-slot-warning-checkbox-group {
      display: flex;
      align-items: center;
      margin-bottom: 16px;
    }
    .form-group.min-slot-warning-checkbox-group label {
      margin-bottom: 0; /* Remove bottom margin to align with checkbox */
      margin-left: 10px; /* Space between checkbox and label */
    }
    .form-group.min-slot-warning-checkbox-group input[type="checkbox"] {
      width: auto; /* Allow checkbox to take its natural width */
      padding: 0; /* Remove padding */
      margin: 0; /* Remove margin */
    }
    .form-actions { display: flex; justify-content: flex-end; gap: 10px; margin-top: 20px; }

    .setting-toggle-button {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px 15px;
      border-radius: 8px;
      cursor: pointer;
      transition: background-color 0.2s, border-color 0.2s;
      margin-bottom: 16px;
      border: 2px solid transparent; /* default border */
      position: relative;
    }

    .setting-toggle-button label {
      flex-grow: 1;
      cursor: pointer;
      margin-bottom: 0; /* Override default form-group label margin */
      font-weight: 500;
      padding-right: 10px; /* Space between label and indicator */
    }

    .setting-toggle-button .hint {
      position: absolute;
      bottom: -20px; /* Adjust as needed */
      left: 0;
      font-size: 0.85em;
      color: var(--gray);
      width: 100%;
      margin-top: 5px; /* Space below the button */
    }

    .setting-toggle-indicator {
      padding: 5px 12px;
      border-radius: 5px;
      font-weight: bold;
      color: white;
      min-width: 50px;
      text-align: center;
      transition: background-color 0.2s;
    }

    /* ON state */
    .setting-toggle-button.is-on {
      background-color: rgba(46, 204, 113, 0.1); /* Faded green */
      border-color: var(--success);
    }
    .setting-toggle-button.is-on:hover {
      background-color: var(--accent); /* Red on hover */
      border-color: var(--accent);
    }
    .setting-toggle-button.is-on:hover .setting-toggle-indicator {
      background-color: #c0392b; /* Darker red */
    }
    .setting-toggle-button.is-on .setting-toggle-indicator {
      background-color: var(--success); /* Solid green */
    }

    /* OFF state */
    .setting-toggle-button.is-off {
      background-color: rgba(231, 76, 60, 0.1); /* Faded red */
      border-color: var(--accent);
    }
    .setting-toggle-button.is-off:hover {
      background-color: var(--success); /* Green on hover */
      border-color: var(--success);
    }
    .setting-toggle-button.is-off:hover .setting-toggle-indicator {
      background-color: #27ae60; /* Darker green */
    }
    .setting-toggle-button.is-off .setting-toggle-indicator {
      background-color: var(--accent); /* Solid red */
    }

    /* Dark Mode Overrides */
    body.dark-mode .setting-toggle-button.is-on {
      background-color: rgba(103, 184, 103, 0.15); /* Dark mode faded green */
      border-color: var(--success);
    }
    body.dark-mode .setting-toggle-button.is-on:hover {
      background-color: var(--accent); /* Dark mode red on hover */
      border-color: var(--accent);
    }
    body.dark-mode .setting-toggle-button.is-off {
      background-color: rgba(224, 108, 117, 0.15); /* Dark mode faded red */
      border-color: var(--accent);
    }
    body.dark-mode .setting-toggle-button.is-off:hover {
      background-color: var(--success); /* Dark mode green on hover */
      border-color: var(--success);
    }
    body.dark-mode .setting-toggle-button.is-off .setting-toggle-indicator {
      background-color: var(--accent); /* Solid red */
    }

    @media (max-width: 992px) {
      .dashboard { grid-template-columns: 1fr; }
      .game-details { grid-template-columns: 1fr; }
    }
    @media (max-width: 576px) {
      .game-header { flex-direction: column; align-items: flex-start; gap: 10px; }
      .controls { flex-direction: column; }
      .controls button { width: 100%; }
      .tabs { flex-direction: column; }
    }

    hr {
      border: none;
      border-top: 1px solid var(--light);
      margin: 20px 0;
    }

    #rulesContent p, #rulesContent ul {
      margin-bottom: 1em; /* Adds space below paragraphs and lists */
    }

    #rulesContent li {
      margin-bottom: 0.5em; /* Adds space between list items */
    }

  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1><i class="fas fa-dice"></i> Reroll Challenge</h1>
      <p class="subtitle">Rotate through games with increasing challenges.</p>
      <button class="dark-mode-toggle" onclick="toggleDarkMode()" title="Toggle Dark Mode">
        <i class="fas fa-moon"></i>
      </button>
    </header>

    <div class="tabs">
      <div class="tab active" data-tab="challenge">Challenge</div>
      <div class="tab" data-tab="database">Game & Handicap Database</div>
      <div class="tab" data-tab="rules">Rules</div>
      <div class="tab" data-tab="notes">Notes</div>
    </div>

    <div class="tab-content active" id="challenge-tab">
      <div class="dashboard">
        <div class="games-container">
          <div class="section-header">
            <h2>Your Rotation</h2>
            <div>
              <button class="btn-primary" onclick="addSlot()">
                <i class="fas fa-plus"></i> Add Slot
              </button>
            </div>
          </div>
          <div class="game-list" id="gameList"></div>
        </div>

        <div class="sidebar">
          <div class="panel">
            <h3>Challenge actions</h3>
            <div class="action-buttons">
              <button class="action-button btn-primary" onclick="rollTempHandicap()">
                <i class="fas fa-random"></i> Roll Temporary Handicap
              </button>
              <button class="action-button btn-primary" onclick="rollPermHandicap()">
                <i class="fas fa-random"></i> Roll Permanent Handicap
              </button>
              <button class="action-button btn-success" onclick="completeRotation()">
                <i class="fas fa-flag-checkered"></i> Complete Rotation
              </button>
              <button class="action-button btn-warning" onclick="rollAchievement()">
                <i class="fas fa-trophy"></i> Roll for <span id="rollAchievementButtonText"></span> Token
              </button>
              <button class="action-button btn-purple" onclick="useToken()" id="useTokenBtn">
                <i class="fas fa-coins"></i> Use Token to Clear Handicap
              </button>
              <button class="action-button btn-danger" onclick="showResetModal()">
                <i class="fas fa-trash-alt"></i> Reset Progress
              </button>
              <button class="action-button btn-primary" onclick="refreshUI()" style="margin-top: 15px;">
                <i class="fas fa-sync-alt"></i> Refresh UI
              </button>
            </div>
          </div>

          <div class="panel">
            <h3>Game stats</h3>
            <div class="stats">
              <div class="stat-item">
                <span>Total Games:</span>
                <span id="totalGames">0</span>
              </div>
              <div class="stat-item">
                <span>Completed:</span>
                <span id="completedGames">0</span>
              </div>
              <div class="stat-item">
                <span>Active Handicaps:</span>
                <span id="activeHandicaps">0</span>
              </div>
              <div class="stat-item">
                <span id="totalDeathsLabel">Total Deaths:</span>
                <span id="totalDeaths">0</span>
              </div>
              <div class="stat-item">
                <span>Rotations Completed:</span>
                <span id="rotationsCompleted">0</span>
              </div>
            </div>

            <div class="token-counter">
              <i class="fas fa-coins token-icon"></i>
              <span>Tokens:</span>
              <span class="token-value" id="tokenCount">0</span>
            </div>
          </div>

          <div class="panel">
            <h3>Data management</h3>
            <div class="action-buttons">
              <button class="action-button btn-primary" onclick="showExportModal()">
                <i class="fas fa-file-export"></i> Export Seed
              </button>
              <button class="action-button btn-primary" onclick="showImportModal()">
                <i class="fas fa-file-import"></i> Import Seed
              </button>
            </div>
            <div class="stat-item" style="margin-top: 20px;">
              <span>Total Completed Runs:</span>
              <span id="totalCompletedRunsDisplay">0</span>
              <button class="handicap-btn" title="Clear Total Completed Runs" onclick="clearTotalCompletedRuns()">
                <i class="fas fa-times"></i>
              </button>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="tab-content" id="database-tab">
      <div class="panel">
        <div class="section-header">
          <h2>Game & Handicap Database</h2>
          <button class="btn-primary" onclick="showAddHandicapModal()">
            <i class="fas fa-plus"></i> Add to Database
          </button>
        </div>
        <div class="form-group" style="margin-bottom: 20px;">
          <input type="text" id="databaseSearchInput" placeholder="Search games..." onkeyup="renderDatabase()" style="width: 100%; padding: 10px; border-radius: 6px; border: 1px solid #ddd;"/>
        </div>
        <div class="database-list" id="databaseList"></div>
      </div>
    </div>

    <div class="tab-content" id="rules-tab">
      <div class="panel">
        <div class="section-header">
          <h2 id="rulesPageTitle">Reroll Challenge rules</h2>
          <div>
            <button class="btn-primary" onclick="toggleRulesPageMode()">
              <i class="fas fa-cog"></i> <span id="rulesPageToggleButtonText">Show Settings</span>
            </button>
            <button class="btn-primary" onclick="refreshUI()" style="margin-left: 10px;">
              <i class="fas fa-sync-alt"></i> Refresh
            </button>
          </div>
        </div>

        <div id="rulesContent">
          <h3>Concept</h3>
          <p>The Reroll Challenge began as a way for me to have fun clearing my backlog, games I otherwise was not going to play. It worked by rotating through multiple titles with escalating constraints, keeping things fresh and giving me a reason to stick with them.</p>
          <p>It has since grown into a modular framework & ruleset that can be shaped to fit almost any style of play. Much like a Nuzlocke run in Pokémon, it is a self‑imposed challenge designed to make familiar games feel new again, but here the structure is more streamlined and consistent thanks to the app automatically tracking timers, rotations, and handicaps for you.  </p>
          <p>You can <strong>build your own pool of games</strong> for any platform or genre. You can <strong>create custom handicap lists</strong>, split into permanent and temporary rules, which are then pulled at random during play to keep you adapting on the fly. You can <strong>adjust rotation rules</strong> to swap games after a set time, a death, a level, or any trigger you choose. You can <strong>dynamically set different timers</strong> for each game, so a speedrun segment might get 15 minutes while a longer endurance section gets an hour. You can <strong>export and import seeds</strong> so others can run the exact same setup, whether for casual play, community races, or competitive speedruns.</p>
          <p>Because the system does not hook into game code, it works with any game. You can apply the same framework to everything you play and customise the rules to fit your style. A long form endurance run might rotate between three RPGs, each with its own 90 minute timer and strict resource limits. A short experimental session could cycle through several platformers in 10 minute bursts with temporary handicaps like "must keep moving" or "no jumping for 30 seconds." A structured speedrun race could give each game a different timer based on its category length, paired with handicaps that force new routes or strategies. A community challenge night might use a viewer submitted seed with a curated mix of games, timers, and rules that everyone can load and attempt.</p>
          <hr>

          <h3>Rotation and Sessions</h3>
          <p>Set up <strong>1–10 slots</strong>, each representing one game in your rotation order. The challenge works with any number, but more slots create more variety and allow temporary handicaps to spread across multiple games. Slots can also be used for different categories of the same game, alternate save files, or different difficulty settings.</p>
          <p>Each session lasts <strong>1 hour per slot</strong>, tracked with the slot's timer widget. The timer length is fully adjustable per slot. You can give a speedrun segment 15 minutes, a grind heavy RPG 90 minutes, or run without a timer for a play until death format.</p>
          <p>Progress through slots in order. When the final slot finishes, the rotation repeats. At the end of each rotation, all temporary handicaps are cleared.</p>
          <hr>

          <h3>Deaths and Temporary Handicaps</h3>
          <p>When you die in a slot, immediately switch to the next slot. You can change this trigger to something else, such as swapping on boss defeat, level completion, or a set number of in game days.</p>
          <p>That death also triggers a <strong>temporary handicap</strong> assigned to a future slot within the same rotation. Only slots appearing after the current slot can receive the handicap. Slot 1 is immune to temporary handicaps caused in prior rotations, since all temps clear at rotation end.</p>
          <p>Temporary handicaps always last <strong>one session</strong> and naturally stack if multiple deaths target the same future slot. In a large rotation, the final slot can end up carrying several temporary handicaps at once.</p>
          <hr>

          <h3>Permanent Handicaps</h3>
          <p>Permanent handicaps are <strong>game specific constraints</strong> that persist across rotations. You can make these as light or as punishing as you want, from "no fast travel" to "permadeath for party members."</p>
          <p>Each game can have a maximum of <strong>3 permanent handicaps</strong> to avoid softlocks. The option to raise or lower this cap will be added in a future update.</p>
          <p>Rolling a permanent handicap selects from that game's database pool, avoiding duplicates.</p>
          <p>At the end of each rotation there is a <strong>1% chance</strong> to clear all permanent handicaps. This chance is configurable in the <strong>Optional Rules (Settings)</strong> page.</p>
          <p><strong>Beating a game completely</strong> immediately clears <strong>2–3 random permanent handicaps</strong> from your active slots, giving a strong incentive to finish titles rather than just rotate through them.</p>
          <hr>

          <h3>Tokens and <span id="rulesAchievementsTitle">Achievements</span></h3>
          <p>Every <span id="rulesAchievementText1">achievement</span> earned (in any game) has a <strong>20% chance</strong> to grant a token. This chance is configurable in the <strong>Optional Rules (Settings)</strong> page, where you can also tie tokens to other milestones.</p>
          <p>Tokens can clear <strong>one permanent handicap</strong>.</p>
          <p>You may use at most <strong>one token per rotation</strong>.</p>
          <hr>

          <h3>Rotation End</h3>
          <p>Finishing a rotation (dying in the final game, or reaching the hour timer) clears all temporary handicaps.</p>
          <p>There is a <strong>1% chance</strong> at rotation end to also clear all permanent handicaps (configurable in the <strong>Optional Rules (Settings)</strong> page).</p>
          <p>The rotation counter increases by one, and token usage limits reset.</p>
          <hr>

          <h3>Database and Slots</h3>
          <p>Maintain a database of games with separate pools for permanent and temporary handicaps. You can keep multiple databases for different genres, difficulty levels, or community events.</p>
          <p>Each slot lets you select a game from the database via a dropdown.</p>
          <p>Handicaps are automatically pulled for whatever game is actively slotted.</p>
          <p>Manual handicap assignment is now available and can be enabled in the <strong>Optional Rules (Settings)</strong> page for curated challenges.</p>
          <hr>

          <h3>Goal</h3>
          <p>Clear all games in the <strong>fewest rotations possible</strong>. Fewer deaths, smarter plays, faster clears. Clearing a game entirely not only removes it from your backlog but also clears <strong>3–4 random permanent handicaps</strong>, making it a powerful way to improve your odds in the rest of the challenge. Or adapt the system for variety streaming, speedrun gauntlets, or community challenge events.</p>
        </div>

        <div id="settingsContent" style="display: none;">
          <h2>Reroll Challenge Settings</h2>
          <p>Here you can customize various aspects of your challenge.</p>

          <div style="background-color: #fff3cd; border-left: 4px solid #ffc107; padding: 10px; margin-bottom: 20px; border-radius: 4px; color: #664d03;">
            <strong>Note:</strong> Some changes may require a UI refresh to take full effect. Click the 'Refresh' button above.
          </div>

          <div class="form-group">
            <label for="tokenDropRateInput"><span id="settingsAchievementDropRateLabel">Achievement</span> Token Drop Rate (%)</label>
            <input type="number" id="tokenDropRateInput" min="0" max="100" step="1" value="20" onchange="updateSetting('tokenDropRate', this.value / 100)" />
            <p class="hint"><span id="settingsAchievementHint1"></span> Default: 20%</p>
          </div>

          <div class="form-group">
            <label for="permClearChanceInput">Rotation End Permanent Handicap Clear Chance (%)</label>
            <input type="number" id="permClearChanceInput" min="0" max="100" step="1" value="1" onchange="updateSetting('permClearChance', this.value / 100)" />
            <p class="hint">At the end of each rotation, all permanent handicaps have this chance to be cleared. Default: 1%</p>
          </div>

          <div class="form-group">
            <label for="deathSystemNameInput">Name of Death Mechanic</label>
            <input type="text" id="deathSystemNameInput" value="Deaths" onchange="updateSetting('deathSystemName', this.value)" />
            <p class="hint">Customize the name for the 'Deaths' mechanic. This will update throughout the application. Default: Deaths</p>
          </div>

          <div class="form-group">
            <label for="achievementSystemNameInput">Name of Achievement System</label>
            <input type="text" id="achievementSystemNameInput" value="Achievement" onchange="updateSetting('achievementSystemName', this.value)" />
            <p class="hint">Customize the name for the 'Achievement' mechanic. This will update throughout the application. Default: Achievement</p>
          </div>

          <hr>

          <h3>Toggle Settings</h3>
          <div class="settings-toggle-group">
            <div class="form-group setting-toggle-button" id="manualHandicapsToggleContainer" onclick="toggleSettingUI('manualHandicapsEnabled')">
              <label>Enable Manual Handicap Assignment</label>
              <span class="setting-toggle-indicator"></span>
              <p class="hint">Allows manual assignment of handicaps to slots, overriding automatic rolls. Default: Disabled</p>
            </div>

            <div class="form-group setting-toggle-button" id="disableAutomatedHandicapGainsToggleContainer" onclick="toggleSettingUI('disableAutomatedHandicapGains')">
              <label>Disable Automated Handicap Gains (experimental)</label>
              <span class="setting-toggle-indicator"></span>
              <p class="hint">If enabled, temporary and permanent handicaps will not be automatically added after deaths or rotation completion. Default: Disabled</p>
            </div>

            <div class="form-group setting-toggle-button" id="disableAutomatedHandicapRemovalsToggleContainer" onclick="toggleSettingUI('disableAutomatedHandicapRemovals')">
              <label>Disable Automated Handicap Removals (experimental)</label>
              <span class="setting-toggle-indicator"></span>
              <p class="hint">If enabled, permanent handicaps will not be automatically removed when a game is completed or at rotation end. Default: Disabled</p>
            </div>

            <div class="form-group setting-toggle-button" id="customMaxPermHandicapsToggleContainer" onclick="toggleSettingUI('customMaxPermHandicapsEnabled')">
              <label>Enable Custom Max Permanent Handicaps</label>
              <span class="setting-toggle-indicator"></span>
              <p class="hint">If enabled, you can set a custom maximum number of permanent handicaps per game. Default: Disabled</p>
            </div>

            <div class="form-group setting-toggle-button" id="dontShowMinSlotWarningToggleContainer" onclick="toggleSettingUI('dontShowMinSlotWarning')">
              <label>Don't show minimum slot warning</label>
              <span class="setting-toggle-indicator"></span>
              <p class="hint">If checked, the warning about removing slots when 3 or fewer are active will not be shown. Default: Disabled</p>
            </div>
          </div>
          <hr>

          <h3>Rarity Settings</h3>
          <div id="raritySettingsContainer"></div>

        </div>
      </div>
    </div>

    <div class="tab-content" id="notes-tab">
      <div class="panel">
        <div class="section-header">
          <h2>Challenge Notes</h2>
          <div>
            <button class="btn-success" onclick="saveNotes()">
              <i class="fas fa-save"></i> Save Notes
            </button>
          </div>
        </div>
        <div class="form-group">
          <textarea id="challengeNotes" rows="15" placeholder="Write your challenge notes here..."></textarea>
        </div>
      </div>
    </div>

    <footer>
      <p>Reroll Challenge v1.2 — Share with friends and challenge yourselves!</p>
    </footer>
  </div>

  <!-- Add Handicap Modal -->
  <div class="modal" id="addHandicapModal">
    <div class="modal-content">
      <div class="modal-header">
        <h2>Add to database</h2>
        <span class="close" onclick="closeModal('addHandicapModal')">&times;</span>
      </div>
      <div class="form-group">
        <label for="dbGameName">Game</label>
        <div style="display:flex; gap:10px;">
          <select id="dbGameSelect" style="flex:1"></select>
          <input id="dbGameName" placeholder="Or type a new game" style="flex:1"/>
        </div>
      </div>
      <div class="form-group">
        <label for="handicapType">Handicap type</label>
        <select id="handicapType">
          <option value="permanent">Permanent</option>
          <option value="temporary">Temporary</option>
        </select>
      </div>
      <div class="form-group">
        <label for="handicapRarity">Rarity</label>
        <select id="handicapRarity"></select>
      </div>
      <div class="form-group">
        <label for="handicapName">Handicap name</label>
        <input id="handicapName" placeholder="Enter handicap name"/>
      </div>
      <div class="form-group">
        <label for="handicapDescription">Description (optional)</label>
        <textarea id="handicapDescription" placeholder="Enter description"></textarea>
      </div>
      <div class="form-group" id="maxPermHandicapsGroup">
        <label for="maxPermHandicapsInput">Max Permanent Handicaps (for this game)</label>
        <input type="number" id="maxPermHandicapsInput" min="1" value="3"/>
      </div>
      <div class="form-group">
        <label for="bulkHandicaps">Add multiple handicaps (one per line)</label>
        <textarea id="bulkHandicaps" rows="6" placeholder="Enter handicaps, one per line"></textarea>
      </div>
      <div class="form-actions">
        <button class="btn-danger" onclick="closeModal('addHandicapModal')">Cancel</button>
        <button class="btn-primary" onclick="addBulkHandicaps()">Add All</button>
        <button class="btn-success" onclick="addNewHandicap()">Add Single</button>
      </div>
    </div>
  </div>

  <!-- Edit Game Modal -->
  <div class="modal" id="editGameModal">
    <div class="modal-content">
      <div class="modal-header">
        <h2>Edit Game Name</h2>
        <span class="close" onclick="closeModal('editGameModal')">&times;</span>
      </div>
      <input type="hidden" id="originalGameName">
      <div class="form-group">
        <label for="editedGameName">Game Name</label>
        <input id="editedGameName" placeholder="Enter new game name"/>
      </div>
      <div class="form-group">
        <label for="editedMaxPermHandicaps">Max Permanent Handicaps</label>
        <input type="number" id="editedMaxPermHandicaps" min="1" value="3"/>
      </div>
      <div class="form-actions">
        <button class="btn-danger" onclick="closeModal('editGameModal')">Cancel</button>
        <button class="btn-success" onclick="saveEditedGame()">Save Changes</button>
      </div>
    </div>
  </div>

  <!-- Edit Handicap Modal -->
  <div class="modal" id="editHandicapModal">
    <div class="modal-content">
      <div class="modal-header">
        <h2>Edit Handicap</h2>
        <span class="close" onclick="closeModal('editHandicapModal')">&times;</span>
      </div>
      <!-- Hidden fields to store original handicap data -->
      <input type="hidden" id="originalEditGameName">
      <input type="hidden" id="originalEditHandicapType">
      <input type="hidden" id="originalEditHandicap">
      <input type="hidden" id="originalEditHandicapRarity">
      <div class="form-group">
        <label for="editGameName">Game</label>
        <div style="display:flex; gap:10px;">
          <select id="editGameSelect" style="flex:1"></select>
          <input id="editGameName" placeholder="Or type a new game" style="flex:1"/>
        </div>
      </div>
      <div class="form-group">
        <label for="editHandicapType">Handicap type</label>
        <select id="editHandicapType">
          <option value="permanent">Permanent</option>
          <option value="temporary">Temporary</option>
        </select>
      </div>
      <div class="form-group">
        <label for="editHandicapRarity">Rarity</label>
        <select id="editHandicapRarity"></select>
      </div>
      <div class="form-group">
        <label for="editHandicapName">Handicap name</label>
        <input id="editHandicapName" placeholder="Enter handicap name"/>
      </div>
      <div class="form-group">
        <label for="editHandicapDescription">Description (optional)</label>
        <textarea id="editHandicapDescription" placeholder="Enter description"></textarea>
      </div>
      <div class="form-actions">
        <button class="btn-danger" onclick="closeModal('editHandicapModal')">Cancel</button>
        <button class="btn-success" onclick="saveEditedHandicap()">Save</button>
      </div>
    </div>
  </div>

  <!-- Reset Modal -->
  <div class="modal" id="resetModal">
    <div class="modal-content">
      <div class="modal-header">
        <h2>Reset progress</h2>
        <span class="close" onclick="closeModal('resetModal')">&times;</span>
      </div>
      <p>This will clear deaths, timers, temporary handicaps, permanent handicaps attached to slots, token usage in rotation, tokens, and rotations count.</p>
      <div class="form-actions">
        <button class="btn-primary" onclick="closeModal('resetModal')">Cancel</button>
        <button class="btn-danger" onclick="resetProgress()">Reset Progress</button>
      </div>
    </div>
  </div>

  <!-- Export Modal -->
  <div class="modal" id="exportModal">
    <div class="modal-content">
      <div class="modal-header">
        <h2>Export seed</h2>
        <span class="close" onclick="closeModal('exportModal')">&times;</span>
      </div>
      <p>Copy the seed below to save your entire challenge state (slots, timers, handicaps, database, tokens, etc.).</p>
      <div class="form-group">
        <textarea id="exportData" rows="8" readonly style="width:100%; font-family:monospace;"></textarea>
      </div>
      <div class="form-actions">
        <button class="btn-primary" onclick="copyExportData()"><i class="fas fa-copy"></i> Copy</button>
        <button class="btn-success" onclick="downloadSeedAsTxt()"><i class="fas fa-download"></i> Download .txt</button>
        <button class="btn-danger" onclick="closeModal('exportModal')">Close</button>
      </div>
    </div>
  </div>

  <!-- Manual Assign Handicap Modal -->
  <div class="modal" id="manualAssignHandicapModal">
    <div class="modal-content">
      <div class="modal-header">
        <h2>Manually Assign Handicap</h2>
        <span class="close" onclick="closeModal('manualAssignHandicapModal')">&times;</span>
      </div>
      <input type="hidden" id="manualAssignSlotId">
      <div class="form-group">
        <label for="manualAssignGameName">Game</label>
        <input type="text" id="manualAssignGameName" readonly />
      </div>
      <div class="form-group">
        <label for="manualAssignHandicapType">Handicap type</label>
        <select id="manualAssignHandicapType" onchange="populateManualHandicaps()">
          <option value="permanent">Permanent</option>
          <option value="temporary">Temporary</option>
        </select>
      </div>
      <div class="form-group">
        <label for="manualAssignHandicap">Select Handicap</label>
        <select id="manualAssignHandicap">
          <option value="">-- Select a handicap --</option>
        </select>
      </div>
      <div class="form-actions">
        <button class="btn-danger" onclick="closeModal('manualAssignHandicapModal')">Cancel</button>
        <button class="btn-success" onclick="assignManualHandicap()">Assign</button>
      </div>
    </div>
  </div>

  <!-- Import Modal -->
  <div class="modal" id="importModal">
    <div class="modal-content">
      <div class="modal-header">
        <h2>Import seed</h2>
        <span class="close" onclick="closeModal('importModal')">&times;</span>
      </div>
      <p>Paste a previously exported seed to restore everything.</p>
      <div class="form-group">
        <textarea id="importData" rows="8" style="width:100%; font-family:monospace;" placeholder="Paste seed here"></textarea>
      </div>
      <div class="form-group" style="margin-top: 20px;">
        <label for="importFile">Or import from .txt file:</label>
        <input type="file" id="importFile" accept=".txt" style="width:100%; padding: 10px 0;"/>
      </div>
      <div class="form-actions">
        <button class="btn-success" onclick="importChallengeData()"><i class="fas fa-file-import"></i> Import</button>
        <button class="btn-primary" onclick="importSeedFromFile()"><i class="fas fa-file-upload"></i> Import from File</button>
        <button class="btn-danger" onclick="closeModal('importModal')">Cancel</button>
      </div>
    </div>
  </div>

  <!-- Result Modal -->
  <div class="modal" id="resultModal">
    <div class="modal-content">
      <div class="modal-header">
        <h2 id="resultTitle">Result</h2>
        <span class="close" onclick="closeModal('resultModal')">&times;</span>
      </div>
      <div id="resultContent"></div>
    </div>
  </div>

  <!-- Minimum Slots Warning Modal -->
  <div class="modal" id="minSlotWarningModal">
    <div class="modal-content">
      <div class="modal-header">
        <h2>Warning: Fewer Slots May Increase Difficulty</h2>
        <span class="close" onclick="closeModal('minSlotWarningModal')">&times;</span>
      </div>
      <p>The Reroll Challenge was originally designed around having at least 3 active games for the early game of the challenge. Reducing the number of active slots below this may significantly increase the challenge's difficulty, especially when using default rules.</p>
      <p>Are you sure you want to proceed with removing this slot?</p>
      <div class="form-group min-slot-warning-checkbox-group">
        <input type="checkbox" id="dontShowMinSlotWarningModalToggle" onchange="updateSetting('dontShowMinSlotWarning', this.checked)" />
        <label for="dontShowMinSlotWarningModalToggle">Don't show this warning again</label>
      </div>
      <div class="form-actions">
        <button class="btn-danger" onclick="closeModal('minSlotWarningModal'); handleMinSlotWarningResponse(false);">Cancel</button>
        <button class="btn-primary" onclick="closeModal('minSlotWarningModal'); handleMinSlotWarningResponse(true);">Proceed</button>
      </div>
    </div>
  </div>

  <script>
    // Core data
    let challengeData = {
      slots: [],
      rotationsCompleted: 0,
      tokens: 0,
      tokenUsedThisRotation: false,
      gameDatabase: [],
      permHandicaps: {},
      tempHandicaps: {},
      totalCompletedRuns: 0, // New counter for total completed runs
      challengeNotes: "", // New field for user notes
      darkMode: false, // New field for dark mode state
      gameSettings: {}, // Stores game-specific settings, e.g., max permanent handicaps
      // New modular rules page settings
      tokenDropRate: 0.20, // 20% chance
      permClearChance: 0.01, // 1% chance
      manualHandicapsEnabled: false, // Default to false
      deathSystemName: 'Deaths', // Default name for the death mechanic
      disableAutomatedHandicapGains: false, // Default to false (experimental)
      disableAutomatedHandicapRemovals: false, // Default to false (experimental)
      customMaxPermHandicapsEnabled: false, // Default to false
      dontShowMinSlotWarning: false, // New setting for warning on removing down to 2 slots
      rarityTiers: { // Default rarity tiers and weights
        "Common": { weight: 10, colorClass: "rarity-common" },
        "Uncommon": { weight: 6, colorClass: "rarity-uncommon" },
        "Rare": { weight: 3, colorClass: "rarity-rare" },
        "Legendary": { weight: 1, colorClass: "rarity-legendary" },
        "Mythic": { weight: 0.5, colorClass: "rarity-mythic" }
      }
    };

    let slotToRemoveId = null; // New global variable to store the ID of the slot to be removed

    // Sample seeds for first run
    const sampleGames = [
      "Vampire: The Masquerade – Bloodlines",
      "Enderal",
      "Amazing Cultivation Simulator",
      "Fallout 76",
      "Age of Decadence"
    ];
    const samplePermHandicaps = {
      "Vampire: The Masquerade – Bloodlines": [
        { name: "Clan Loyalty", description: "Must pick one Discipline and always prioritize it when spending XP", rarity: "Common" },
        { name: "No Easy Meal", description: "Must avoid feeding on innocents; only feed on criminals, enemies, or blood packs", rarity: "Uncommon" }
      ],
      "Enderal": [
        { name: "Ascetic Path", description: "No food/drink buffs", rarity: "Common" },
        { name: "Class Purist", description: "Stick to one archetype tree", rarity: "Rare" }
      ],
      "Amazing Cultivation Simulator": [
        { name: "No Outer Sect", description: "Cannot recruit or interact with any outer sects for the rest of the run", rarity: "Uncommon" },
        { name: "One Life", description: "If a disciple dies, the run ends", rarity: "Legendary" }
      ],
      "Fallout 76": [
        { name: "Scavenger Only", description: "No vendor purchases", rarity: "Common" },
        { name: "Pacifist Trades", description: "No PvP engagements", rarity: "Uncommon" }
      ],
      "Age of Decadence": [
        { name: "No Save Scum", description: "One try per check", rarity: "Rare" },
        { name: "Faction Loyalist", description: "Commit to first faction choice", rarity: "Common" }
      ]
    };
    const sampleTempHandicaps = {
      "Vampire: The Masquerade – Bloodlines": [
        { name: "Hunger Unchecked", description: "Cannot feed until the end of the current questline", rarity: "Uncommon" },
        { name: "Beast's Restraint", description: "No blood disciplines in one major dungeon", rarity: "Common" }
      ],
      "Enderal": [
        { name: "The Long Night", description: "Travel only by night", rarity: "Uncommon" },
        { name: "Blind Pilgrim", description: "No map use for one major journey", rarity: "Rare" }
      ],
      "Amazing Cultivation Simulator": [
        { name: "One Disciple Sect", description: "Limit recruitment to one disciple for this session", rarity: "Common" },
        { name: "Manual Labor Only", description: "No automation this session", rarity: "Rare" }
      ],
      "Fallout 76": [
        { name: "Iron Stomach", description: "No food buffs this session", rarity: "Uncommon" },
        { name: "Barebones", description: "No Power Armor this session", rarity: "Common" }
      ],
      "Age of Decadence": [
        { name: "No Merchants", description: "Use only looted gear this session", rarity: "Uncommon" },
        { name: "Silent Tongue", description: "No persuasion checks this session", rarity: "Common" }
      ]
    };

    // Init
    function init() {
      const saved = localStorage.getItem('rerollChallengeData');
      if (saved) {
        try {
          challengeData = JSON.parse(saved);
          // Ensure totalCompletedRuns is a number
          challengeData.totalCompletedRuns = Number(challengeData.totalCompletedRuns) || 0;
          // Ensure new settings have default values if not present in saved data
          challengeData.tokenDropRate = challengeData.tokenDropRate !== undefined ? challengeData.tokenDropRate : 0.20;
          challengeData.permClearChance = challengeData.permClearChance !== undefined ? challengeData.permClearChance : 0.01;
          challengeData.manualHandicapsEnabled = challengeData.manualHandicapsEnabled !== undefined ? challengeData.manualHandicapsEnabled : false;
          challengeData.deathSystemName = challengeData.deathSystemName || 'Deaths';
          challengeData.disableAutomatedHandicapGains = challengeData.disableAutomatedHandicapGains !== undefined ? challengeData.disableAutomatedHandicapGains : false;
          challengeData.disableAutomatedHandicapRemovals = challengeData.disableAutomatedHandicapRemovals !== undefined ? challengeData.disableAutomatedHandicapRemovals : false;
          challengeData.customMaxPermHandicapsEnabled = challengeData.customMaxPermHandicapsEnabled !== undefined ? challengeData.customMaxPermHandicapsEnabled : false;
          challengeData.dontShowMinSlotWarning = challengeData.dontShowMinSlotWarning !== undefined ? challengeData.dontShowMinSlotWarning : false;
          challengeData.challengeNotes = challengeData.challengeNotes !== undefined ? challengeData.challengeNotes : ""; // Ensure notes are loaded
          challengeData.darkMode = challengeData.darkMode !== undefined ? challengeData.darkMode : false; // Ensure dark mode setting is loaded
          challengeData.gameSettings = challengeData.gameSettings !== undefined ? challengeData.gameSettings : {}; // Initialize game settings

          challengeData.achievementSystemName = challengeData.achievementSystemName || 'Achievement';

          // Initialize rarityTiers if not present (for backward compatibility)
          if (!challengeData.rarityTiers) {
            challengeData.rarityTiers = {
              "Common": { weight: 10, colorClass: "rarity-common" },
              "Uncommon": { weight: 6, colorClass: "rarity-uncommon" },
              "Rare": { weight: 3, colorClass: "rarity-rare" },
              "Legendary": { weight: 1, colorClass: "rarity-legendary" },
              "Mythic": { weight: 0.5, colorClass: "rarity-mythic" }
            };
          }

          // Migrate old handicap format to new object format with default rarity
          for (const game in challengeData.permHandicaps) {
            if (Array.isArray(challengeData.permHandicaps[game]) && challengeData.permHandicaps[game].length > 0 && typeof challengeData.permHandicaps[game][0] === 'string') {
              challengeData.permHandicaps[game] = challengeData.permHandicaps[game].map(h => {
                const parts = h.split(' - ');
                return { name: parts[0], description: parts.length > 1 ? parts.slice(1).join(' - ') : '', rarity: 'Common' };
              });
            }
          }
          for (const game in challengeData.tempHandicaps) {
            if (Array.isArray(challengeData.tempHandicaps[game]) && challengeData.tempHandicaps[game].length > 0 && typeof challengeData.tempHandicaps[game][0] === 'string') {
              challengeData.tempHandicaps[game] = challengeData.tempHandicaps[game].map(h => {
                const parts = h.split(' - ');
                return { name: parts[0], description: parts.length > 1 ? parts.slice(1).join(' - ') : '', rarity: 'Common' };
              });
            }
          }

          // Ensure each game in the database has a maxPermHandicaps setting
          challengeData.gameDatabase.forEach(game => {
            if (!challengeData.gameSettings[game]) {
              challengeData.gameSettings[game] = { maxPermHandicaps: 3 };
            } else if (challengeData.gameSettings[game].maxPermHandicaps === undefined) {
              challengeData.gameSettings[game].maxPermHandicaps = 3;
            }
          });

          // Clean up timer intervals if any persisted incorrectly
          challengeData.slots.forEach(s => { s.timerInterval = null; s.timerActive = false; });
        } catch {
          loadSample();
        }
      } else {
        loadSample();
      }
      ensureAtLeastThreeSlots();

      // Apply dark mode immediately on init if enabled
      if (challengeData.darkMode) {
        document.body.classList.add('dark-mode');
        const toggleBtn = document.querySelector('.dark-mode-toggle i');
        if (toggleBtn) {
          toggleBtn.classList.remove('fa-moon');
          toggleBtn.classList.add('fa-sun');
        }
      }

      renderGames();
      updateStats();
      updateTokenButton();
      renderDatabase();
      setupTabs();
      renderSettings(); // Initialize settings UI
      loadNotes(); // Load notes when initializing

      // Update achievement button text in init
      // document.getElementById('rollAchievementButtonText').textContent = challengeData.achievementSystemName;
    }

    function loadSample() {
      challengeData = {
        slots: [],
        rotationsCompleted: 0,
        tokens: 0,
        tokenUsedThisRotation: false,
        gameDatabase: [...sampleGames],
        permHandicaps: JSON.parse(JSON.stringify(samplePermHandicaps)),
        tempHandicaps: JSON.parse(JSON.stringify(sampleTempHandicaps)),
        totalCompletedRuns: 0, // Initialize for sample data
        rarityTiers: { // Default rarity tiers and weights for sample data
          "Common": { weight: 10, colorClass: "rarity-common" },
          "Uncommon": { weight: 6, colorClass: "rarity-uncommon" },
          "Rare": { weight: 3, colorClass: "rarity-rare" },
          "Legendary": { weight: 1, colorClass: "rarity-legendary" },
          "Mythic": { weight: 0.5, colorClass: "rarity-mythic" }
        },
        achievementSystemName: 'Achievement' // Initialize for sample data
      };
      // Initialize gameSettings for sample games
      sampleGames.forEach(game => {
        challengeData.gameSettings[game] = { maxPermHandicaps: 3 };
      });
    }

    function ensureAtLeastThreeSlots() {
      while (challengeData.slots.length < 3) {
        challengeData.slots.push(newSlot(challengeData.slots.length + 1));
      }
    }

    function newSlot(id) {
      return {
        id,
        game: "",
        progress: "Not Started",
        deaths: 0,
        permanentHandicaps: [], // Now stores handicap objects
        temporaryHandicaps: [], // Now stores handicap objects
        timer: 3600, // Initialize to 60 minutes (3600 seconds)
        timerActive: false,
        timerInterval: null,
        sessionDuration: 3600 // New property for customizable duration
      };
    }

    function saveData() {
      localStorage.setItem('rerollChallengeData', JSON.stringify(challengeData));
    }

    // Tabs
    function setupTabs() {
      document.querySelectorAll('.tab').forEach(tab => {
        tab.addEventListener('click', () => {
          const name = tab.getAttribute('data-tab');
          document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
          document.querySelectorAll('.tab-content').forEach(tc => tc.classList.remove('active'));
          tab.classList.add('active');
          document.getElementById(`${name}-tab`).classList.add('active');
          // If the notes tab is clicked, load the saved notes
          if (name === 'notes') {
            loadNotes();
          }
        });
      });
    }

    // Render challenge slots
    function renderGames() {
      const gameList = document.getElementById('gameList');
      gameList.innerHTML = '';

      const activeSlots = challengeData.slots.filter(s => s.progress !== 'Completed').sort((a,b) => a.id - b.id);
      const completedSlots = challengeData.slots.filter(s => s.progress === 'Completed').sort((a,b) => a.id - b.id);

      activeSlots.forEach(slot => {
        const card = document.createElement('div');
        card.className = 'game-card';
        card.setAttribute('draggable', 'true');
        card.setAttribute('data-slot-id', slot.id);

        const timerMinutes = Math.floor(slot.timer / 60);
        const timerSeconds = slot.timer % 60;
        const timerDisplay = `${timerMinutes.toString().padStart(2, '0')}:${timerSeconds.toString().padStart(2, '0')}`;

        card.innerHTML = `
          <div class="game-header">
            <div class="game-title">
              <span>Slot ${slot.id}</span>
              <div class="searchable-dropdown" id="game-select-${slot.id}">
                <input type="text" placeholder="Select a game..." value="${escapeAttr(slot.game)}" onfocus="this.select(); renderSearchableDropdown(this, ${slot.id});" oninput="renderSearchableDropdown(this, ${slot.id});" onblur="hideSearchableDropdown(this);" data-slot-id="${slot.id}"/>
                <div class="searchable-dropdown-results"></div>
              </div>
            </div>
            <div class="game-progress">
              <span>${challengeData.deathSystemName}: ${slot.deaths}</span>
            </div>
            <button class="game-delete-btn" onclick="removeSlot(${slot.id})" title="Remove Slot">
              
            </button>
          </div>

          ${slot.game ? `
            <div class="game-details">
              <div class="handicap-section">
                <strong>Permanent Handicaps</strong>
                ${slot.permanentHandicaps.length > 0 ?
                  slot.permanentHandicaps.map(h => `
                    <div class="handicap permanent">
                      <span class="${challengeData.rarityTiers[h.rarity]?.colorClass || ''}">${escapeHtml(h.name + (h.description ? ' - ' + h.description : ''))} (${h.rarity})</span>
                      <div class="handicap-actions">
                        <button class="handicap-btn" title="Remove" onclick="clearSpecificHandicap(${slot.id}, 'permanent', '${escapeAttr(h.name + (h.description ? ' - ' + h.description : ''))}')">
                          <i class="fas fa-times"></i>
                        </button>
                      </div>
                    </div>
                  `).join('') : `<div class="handicap">None</div>`
                }
              </div>
              <div class="handicap-section">
                <strong>Temporary Handicaps</strong>
                ${slot.temporaryHandicaps.length > 0 ?
                  slot.temporaryHandicaps.map(h => `
                    <div class="handicap temporary">
                      <span class="${challengeData.rarityTiers[h.rarity]?.colorClass || ''}">${escapeHtml(h.name + (h.description ? ' - ' + h.description : ''))} (${h.rarity})</span>
                      <div class="handicap-actions">
                        <button class="handicap-btn" title="Remove" onclick="clearSpecificHandicap(${slot.id}, 'temporary', '${escapeAttr(h.name + (h.description ? ' - ' + h.description : ''))}')">
                          <i class="fas fa-times"></i>
                        </button>
                      </div>
                    </div>
                  `).join('') : `<div class="handicap">None</div>`
                }
              </div>
              <div class="handicap-section" style="grid-column: 1 / -1; ${challengeData.customMaxPermHandicapsEnabled ? '' : 'display: none;'}">
                <strong>Max Permanent Handicaps</strong>
                <input type="number" id="slotMaxPermHandicaps-${slot.id}" value="${challengeData.gameSettings[slot.game]?.maxPermHandicaps || 3}" min="1" onchange="updateSlotMaxPermHandicaps(${slot.id}, this.value)" style="width: 80px; padding: 6px; border-radius: 6px; border: 1px solid #ddd; margin-top: 5px;"/>
              </div>
            </div>

            <div class="timer-widget">
              <div class="timer-display">${timerDisplay}</div>
              <button class="timer-btn btn-success" ${slot.timerActive ? 'disabled' : ''} onclick="startTimer(${slot.id})">
                <i class="fas fa-play"></i> Start
              </button>
              <button class="timer-btn btn-warning" ${!slot.timerActive ? 'disabled' : ''} onclick="pauseTimer(${slot.id})">
                <i class="fas fa-pause"></i> Pause
              </button>
              <button class="timer-btn btn-danger" onclick="resetTimer(${slot.id})">
                <i class="fas fa-redo"></i> Reset
              </button>
              <div style="margin-left: auto;">
                <label for="duration-${slot.id}" style="font-size: 0.9em;">Duration (min):</label>
                <input type="number" id="duration-${slot.id}" value="${slot.sessionDuration / 60}" min="1" onchange="updateSessionDuration(${slot.id}, this.value)" style="width: 60px; padding: 4px; border-radius: 4px; border: 1px solid #ddd;"/>
              </div>
            </div>

            <div class="controls">
              <button class="btn-primary" onclick="addDeath(${slot.id})">
                <i class="fas fa-skull"></i> Add ${challengeData.deathSystemName === 'Deaths' ? 'Death' : challengeData.deathSystemName}
              </button>
              <button class="btn-success" onclick="markComplete(${slot.id})">
                <i class="fas fa-check"></i> Mark Complete
              </button>
              ${challengeData.manualHandicapsEnabled && slot.game ? `
                <button class="btn-info" onclick="showManualAssignHandicapModal(${slot.id})">
                  <i class="fas fa-wrench"></i> Assign Handicap
                </button>
              ` : ''}
            </div>
          ` : `
            <div class="handicap">Select a game from the dropdown to begin.</div>
          `}
        `;
        gameList.appendChild(card);
      });

      // Add drag and drop event listeners
      let draggedItem = null;

      document.querySelectorAll('.game-card').forEach(card => {
        card.addEventListener('dragstart', (e) => {
          if (card.classList.contains('completed')) {
            e.preventDefault(); // Prevent dragging completed slots
            return;
          }
          draggedItem = card;
          setTimeout(() => card.classList.add('dragging'), 0);
          e.dataTransfer.effectAllowed = 'move';
          e.dataTransfer.setData('text/plain', card.dataset.slotId);
        });

        card.addEventListener('dragover', (e) => {
          e.preventDefault(); // Allow drop
          if (card !== draggedItem && !card.classList.contains('completed')) {
            card.classList.add('drag-over');
          }
        });

        card.addEventListener('dragleave', () => {
          card.classList.remove('drag-over');
        });

        card.addEventListener('drop', (e) => {
          e.preventDefault();
          card.classList.remove('drag-over');

          if (draggedItem && card !== draggedItem && !card.classList.contains('completed')) {
            const draggedId = parseInt(draggedItem.dataset.slotId);
            const droppedId = parseInt(card.dataset.slotId);

            const newSlots = [...challengeData.slots];
            const draggedSlotIndex = newSlots.findIndex(s => s.id === draggedId);
            const droppedSlotIndex = newSlots.findIndex(s => s.id === droppedId);

            const [removed] = newSlots.splice(draggedSlotIndex, 1);
            newSlots.splice(droppedSlotIndex, 0, removed);

            // Reassign IDs based on new order and re-render
            challengeData.slots = newSlots.map((s, index) => ({ ...s, id: index + 1 }));
            renderGames();
          }
          draggedItem.classList.remove('dragging');
          draggedItem = null;
        });

        card.addEventListener('dragend', () => {
          if (draggedItem) {
            draggedItem.classList.remove('dragging');
            draggedItem = null;
          }
          document.querySelectorAll('.game-card').forEach(c => c.classList.remove('drag-over'));
        });
      });

      if (completedSlots.length > 0) {
        const completedHeader = document.createElement('h2');
        completedHeader.textContent = 'Completed Games';
        completedHeader.style.marginTop = '30px';
        completedHeader.style.borderBottom = '2px solid var(--light)';
        completedHeader.style.paddingBottom = '15px';
        gameList.appendChild(completedHeader);

        completedSlots.forEach(slot => {
          const card = document.createElement('div');
          card.className = 'game-card completed';

          card.innerHTML = `
            <div class="game-header">
              <div class="game-title">
                <i class="fas fa-check-circle" style="color: var(--success);"></i>
                <span>Slot ${slot.id}: ${escapeHtml(slot.game || 'N/A')}</span>
              </div>
              <div class="game-progress">
                <span>Completed | Deaths: ${slot.deaths}</span>
              </div>
            </div>
            <div class="handicap">Game completed! No new handicaps.</div>
          `;
          gameList.appendChild(card);
        });
      }

      updateStats();
      saveData();
    }

    // Stats
    function updateStats() {
      const completed = challengeData.slots.filter(s => s.progress === 'Completed').length;
      const activeHandicaps = challengeData.slots.reduce((t, s) => t + s.permanentHandicaps.length + s.temporaryHandicaps.length, 0);
      const totalDeaths = challengeData.slots.reduce((t, s) => t + s.deaths, 0);
      const totalGames = challengeData.slots.filter(s => !!s.game).length;

      document.getElementById('totalGames').textContent = totalGames;
      document.getElementById('completedGames').textContent = completed;
      document.getElementById('activeHandicaps').textContent = activeHandicaps;
      document.getElementById('totalDeaths').textContent = totalDeaths;
      document.getElementById('rotationsCompleted').textContent = challengeData.rotationsCompleted;
      document.getElementById('tokenCount').textContent = challengeData.tokens;
      document.getElementById('totalCompletedRunsDisplay').textContent = challengeData.totalCompletedRuns; // Update the new counter display

      // Update the death system name in the sidebar stat item title
      document.getElementById('totalDeathsLabel').textContent = `${challengeData.deathSystemName}:`;

      // Update achievement button text
      const rollAchievementButtonText = document.getElementById('rollAchievementButtonText');
      if (rollAchievementButtonText) {
        rollAchievementButtonText.textContent = challengeData.achievementSystemName;
      }
    }

    // Token button
    function updateTokenButton() {
      const btn = document.getElementById('useTokenBtn');
      if (challengeData.tokens > 0 && !challengeData.tokenUsedThisRotation) {
        btn.disabled = false;
        btn.classList.remove('btn-gray');
        btn.classList.add('btn-purple');
      } else {
        btn.disabled = true;
        btn.classList.remove('btn-purple');
        btn.classList.add('btn-gray');
      }
    }

    // Slot mgmt
    function addSlot() {
      if (challengeData.slots.length >= 10) {
        showResult('Maximum Slots', 'You can only have up to 10 slots.');
        return;
      }
      const id = challengeData.slots.length + 1;
      challengeData.slots.push(newSlot(id));
      renderGames();
      showResult('Slot Added', 'Added a new slot to your rotation.');
    }

    function removeSlot(slotId) {
      if (challengeData.slots.length === 3 && !challengeData.dontShowMinSlotWarning) {
        slotToRemoveId = slotId; // Store the slot ID for `handleMinSlotWarningResponse`
        document.getElementById('minSlotWarningModal').style.display = 'flex';
        return new Promise(resolve => {
          resolveMinSlotWarningPromise = resolve;
        }).then(proceed => {
          if (proceed) {
            performRemoveSlot(slotId);
          } else {
            // User cancelled, do nothing
            renderGames();
            saveData();
          }
        });
      } else {
        performRemoveSlot(slotId);
      }
    }

    function performRemoveSlot(slotId) {
      if (challengeData.slots.length === 1) {
        const slot = challengeData.slots[0];
        // Clear the last card instead of deleting it
        if (slot.timerInterval) clearInterval(slot.timerInterval);
        Object.assign(slot, newSlot(slot.id)); // Reset to default state
        showResult('Slot Cleared', 'You cannot remove the last slot. It has been cleared instead.');
      } else {
        const slotIndex = challengeData.slots.findIndex(s => s.id === slotId);
        if (slotIndex === -1) return;

        const removed = challengeData.slots.splice(slotIndex, 1)[0];
        // Stop timer if running
        if (removed.timerInterval) clearInterval(removed.timerInterval);
        
        // Reassign IDs based on new order and re-render
        challengeData.slots = challengeData.slots.map((s, index) => ({ ...s, id: index + 1 }));
        showResult('Slot Removed', `Removed slot ${slotId} from your rotation.`);
      }
      renderGames();
      saveData();
    }

    function updateGame(slotId, gameName) {
      const slot = challengeData.slots.find(s => s.id === slotId);
      if (!slot) return;

      slot.game = gameName || "";
      if (slot.game) {
        // ensure in database
        if (!challengeData.gameDatabase.includes(slot.game)) {
          challengeData.gameDatabase.push(slot.game);
        }
        if (!challengeData.permHandicaps[slot.game]) challengeData.permHandicaps[slot.game] = [];
        if (!challengeData.tempHandicaps[slot.game]) challengeData.tempHandicaps[slot.game] = [];
      }

      renderGames();
      renderDatabase();
      saveData();
    }

    // Deaths
    function addDeath(slotId) {
      const slot = challengeData.slots.find(s => s.id === slotId);
      if (!slot || !slot.game) {
        showResult('No Game Selected', 'Please select a game for this slot before adding deaths.');
        return;
      }

      slot.deaths++;
      
      if (challengeData.disableAutomatedHandicapGains) {
        renderGames();
        showResult('Death Added', `Added a ${challengeData.deathSystemName === 'Deaths' ? 'death' : challengeData.deathSystemName.toLowerCase()} to ${escapeHtml(slot.game)}. Automated handicap gains are disabled.`);
        return;
      }

      // Assign temp handicap to a future slot with a game, excluding Slot 1 and completed slots
      const futureSlots = challengeData.slots.filter(s => s.id > slotId && s.game && s.id !== 1 && s.progress !== 'Completed');
      if (futureSlots.length === 0) {
        renderGames();
        showResult('Death Added', `Added a ${challengeData.deathSystemName === 'Deaths' ? 'death' : challengeData.deathSystemName.toLowerCase()} to ${escapeHtml(slot.game)}.<br>No eligible future slots to assign temporary handicaps.`);
        return;
      }
      const target = futureSlots[Math.floor(Math.random() * futureSlots.length)];
      const pool = challengeData.tempHandicaps[target.game] || [];
      if (pool.length > 0) {
        // Filter out handicaps already present in the target slot
        const availablePool = pool.filter(pHandicap => 
          !target.temporaryHandicaps.some(sHandicap => 
            sHandicap.name === pHandicap.name && sHandicap.description === pHandicap.description && sHandicap.rarity === pHandicap.rarity
          )
        );

        const randomHandicap = getRandomWeightedHandicap(availablePool);
        if (randomHandicap) {
          target.temporaryHandicaps.push(randomHandicap);
          renderGames();
          const fullHandicapText = randomHandicap.name + (randomHandicap.description ? ' - ' + randomHandicap.description : '');
          showResult('Death Added', `Added a ${challengeData.deathSystemName === 'Deaths' ? 'death' : challengeData.deathSystemName.toLowerCase()} to ${escapeHtml(slot.game)}.<br>Temporary handicap added to ${escapeHtml(target.game)}:<br><span class="${challengeData.rarityTiers[randomHandicap.rarity]?.colorClass || ''}"><strong>${escapeHtml(fullHandicapText)} (${randomHandicap.rarity})</strong></span>`);
        } else {
          renderGames();
          showResult('Death Added', `Added a ${challengeData.deathSystemName === 'Deaths' ? 'death' : challengeData.deathSystemName.toLowerCase()} to ${escapeHtml(slot.game)}.<br>No unique temporary handicaps available for the target game, or all have zero weight.`);
        }
        return;
      }
      renderGames();
      showResult('Death Added', `Added a ${challengeData.deathSystemName === 'Deaths' ? 'death' : challengeData.deathSystemName.toLowerCase()} to ${escapeHtml(slot.game)}.<br>No valid future slot or no temp handicaps in the target game pool.`);
    }

    function markComplete(slotId) {
      const slot = challengeData.slots.find(s => s.id === slotId);
      if (!slot) return;
      slot.progress = 'Completed';

      let removedHandicapMessages = [];
      if (challengeData.disableAutomatedHandicapRemovals) {
        // Automated handicap removals are disabled, skip removal logic
        console.log("Automated handicap removals are disabled.");
      } else {
        // Remove 2-3 random permanent handicaps from any game
        const numHandicapsToRemove = Math.floor(Math.random() * 2) + 2; // 2 or 3
        let handicapsRemovedCount = 0;
        let allPermHandicapObjects = [];
        for (const game in challengeData.permHandicaps) {
          challengeData.permHandicaps[game].forEach(h => allPermHandicapObjects.push({ game, handicap: h }));
        }

        // Shuffle available handicaps to pick randomly
        for (let i = allPermHandicapObjects.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [allPermHandicapObjects[i], allPermHandicapObjects[j]] = [allPermHandicapObjects[j], allPermHandicapObjects[i]];
        }

        while (handicapsRemovedCount < numHandicapsToRemove && allPermHandicapObjects.length > 0) {
          const { game, handicap } = allPermHandicapObjects.pop();
          // Remove from any slots that might have this handicap object
          challengeData.slots.forEach(s => {
            if (s.game === game) {
              s.permanentHandicaps = s.permanentHandicaps.filter(hObj => 
                !(hObj.name === handicap.name && hObj.description === handicap.description && hObj.rarity === handicap.rarity)
              );
            }
          });
          removedHandicapMessages.push(`<span class="${challengeData.rarityTiers[handicap.rarity]?.colorClass || ''}"><strong>${escapeHtml(handicap.name + (handicap.description ? ' - ' + handicap.description : ''))} (${handicap.rarity})</strong></span> from <strong>${escapeHtml(game)}</strong>`);
          handicapsRemovedCount++;
        }
      }

      renderGames();
      renderDatabase();
      saveData();
      let message = `Congratulations! You've completed ${escapeHtml(slot.game || 'this slot')}.<br>`;
      if (challengeData.disableAutomatedHandicapRemovals) {
        message += `Automated handicap removals are disabled in settings.`;
      } else if (removedHandicapMessages.length > 0) {
        message += `As a reward, the following permanent handicaps were removed:<br>${removedHandicapMessages.join('<br>')}`;
      } else {
        message += `No permanent handicaps were available to remove.`;
      }

      const allGamesCompleted = challengeData.slots.every(s => s.progress === 'Completed' || !s.game);
      if (allGamesCompleted) {
        message += '<br><br><strong>🎉 Congratulations! You\'ve completed all games in your rotation! 🎉</strong>';
        challengeData.totalCompletedRuns++; // Increment the new counter
        updateStats(); // Update stats display
      }

      showResult('Game Completed', message);
    }

    function clearSpecificHandicap(slotId, type, handicapString) {
      const slot = challengeData.slots.find(s => s.id === slotId);
      if (!slot) return;

      const confirmRemoval = window.confirm(`Are you sure you want to remove the ${type} handicap "${handicapString.split(' - ')[0]}" from ${slot.game}?`);
      if (!confirmRemoval) return;

      const handicapName = handicapString.split(' - ')[0];
      const handicapDescription = handicapString.split(' - ').length > 1 ? handicapString.split(' - ').slice(1).join(' - ') : '';

      if (type === 'permanent') {
        slot.permanentHandicaps = slot.permanentHandicaps.filter(h => !(h.name === handicapName && h.description === handicapDescription));
      } else {
        slot.temporaryHandicaps = slot.temporaryHandicaps.filter(h => !(h.name === handicapName && h.description === handicapDescription));
      }
      renderGames();
      showResult('Handicap Removed', `Removed ${escapeHtml(type)} handicap from ${escapeHtml(slot.game || 'slot')}:<br><strong>${escapeHtml(handicapString)}</strong>`);
    }

    // Rolls
    function getRandomWeightedHandicap(pool) {
      let weightedList = [];
      pool.forEach(handicap => {
        const rarity = handicap.rarity || 'Common'; // Default to Common if rarity is missing
        const weight = challengeData.rarityTiers[rarity]?.weight || challengeData.rarityTiers['Common'].weight; // Default to Common weight
        for (let i = 0; i < weight; i++) {
          weightedList.push(handicap);
        }
      });
      if (weightedList.length === 0) return null;
      return weightedList[Math.floor(Math.random() * weightedList.length)];
    }

    function rollTempHandicap() {
      if (challengeData.disableAutomatedHandicapGains) {
        showResult('Automated Gains Disabled', 'Automated temporary handicap gains are currently disabled in settings.');
        return;
      }
      // any slot with a game and not completed, excluding Slot 1
      const eligible = challengeData.slots.filter(s => s.game && s.progress !== 'Completed' && s.id !== 1);
      if (eligible.length === 0) {
        showResult('No Eligible Slots', 'No eligible slots found for temporary handicaps.');
        return;
      }
      const slot = eligible[Math.floor(Math.random() * eligible.length)];
      const pool = challengeData.tempHandicaps[slot.game] || [];
      if (pool.length === 0) {
        showResult('No Handicaps', `No temporary handicaps found for ${escapeHtml(slot.game)}.`);
        return;
      }
      // Filter out handicaps already present in the slot
      const availablePool = pool.filter(pHandicap => 
        !slot.temporaryHandicaps.some(sHandicap => 
          sHandicap.name === pHandicap.name && sHandicap.description === pHandicap.description && sHandicap.rarity === pHandicap.rarity
        )
      );

      const pick = getRandomWeightedHandicap(availablePool);
      if (pick) {
        slot.temporaryHandicaps.push(pick);
        renderGames();
        const fullHandicapText = pick.name + (pick.description ? ' - ' + pick.description : '');
        showResult('Temporary Handicap', `Added to ${escapeHtml(slot.game)}:<br><span class="${challengeData.rarityTiers[pick.rarity]?.colorClass || ''}"><strong>${escapeHtml(fullHandicapText)} (${pick.rarity})</strong></span>`);
      } else {
        showResult('No Handicaps', `No unique temporary handicaps available for ${escapeHtml(slot.game)}, or all have zero weight.`);
      }
    }

    function rollPermHandicap() {
      if (challengeData.disableAutomatedHandicapGains) {
        showResult('Automated Gains Disabled', 'Automated permanent handicap gains are currently disabled in settings.');
        return;
      }
      const eligible = challengeData.slots.filter(s => s.game && s.progress !== 'Completed');
      if (eligible.length === 0) {
        showResult('No Eligible Slots', 'No eligible slots found for permanent handicaps.');
        return;
      }
      const slot = eligible[Math.floor(Math.random() * eligible.length)];
      const maxPermHandicaps = challengeData.customMaxPermHandicapsEnabled
        ? (challengeData.gameSettings[slot.game]?.maxPermHandicaps || 3)
        : 3; // Always 3 if custom max perm handicaps are disabled

      if (slot.permanentHandicaps.length >= maxPermHandicaps) {
        showResult('Max Handicaps', `${escapeHtml(slot.game)} already has the maximum of ${maxPermHandicaps} permanent handicaps.`);
        return;
      }
      const pool = challengeData.permHandicaps[slot.game] || [];
      if (pool.length === 0) {
        showResult('No Handicaps', `No permanent handicaps found for ${escapeHtml(slot.game)}.`);
        return;
      }
      const available = pool.filter(h => !slot.permanentHandicaps.includes(h));
      if (available.length === 0) {
        showResult('All Applied', `All available permanent handicaps have already been applied to ${escapeHtml(slot.game)}.`);
        return;
      }
      const pick = getRandomWeightedHandicap(available);
      if (pick) {
        slot.permanentHandicaps.push(pick);
        renderGames();
        const fullHandicapText = pick.name + (pick.description ? ' - ' + pick.description : '');
        showResult('Permanent Handicap', `Added to ${escapeHtml(slot.game)}:<br><span class="${challengeData.rarityTiers[pick.rarity]?.colorClass || ''}"><strong>${escapeHtml(fullHandicapText)} (${pick.rarity})</strong></span>`);
      } else {
        showResult('No Handicaps', `No permanent handicaps available or all have zero weight for ${escapeHtml(slot.game)}.`);
      }
    }

    function completeRotation() {
      let clearedAll = false;
      // Chance to clear permanent handicaps based on setting
      if (!challengeData.disableAutomatedHandicapRemovals) {
        if (Math.random() < challengeData.permClearChance) {
          challengeData.slots.forEach(s => s.permanentHandicaps = []);
          clearedAll = true;
        }
      } else {
        console.log("Automated permanent handicap clearing is disabled.");
      }

      // Clear temps, reset token usage, increment rotations
      challengeData.slots.forEach(s => s.temporaryHandicaps = []);
      challengeData.rotationsCompleted++;
      challengeData.tokenUsedThisRotation = false;

      let addedPermHandicapMessage = '';
      if (challengeData.disableAutomatedHandicapGains) {
        addedPermHandicapMessage = `<br>Automated permanent handicap gains are disabled in settings.`;
      } else {
        // Prepare a list of slots that are truly eligible to receive a new permanent handicap
        let trulyEligibleTargets = [];
        challengeData.slots.forEach(slot => {
          const maxPermHandicapsForSlot = challengeData.customMaxPermHandicapsEnabled
            ? (challengeData.gameSettings[slot.game]?.maxPermHandicaps || 3)
            : 3;
          // A slot is eligible if it has a game, is not completed, and has less than its max permanent handicaps
          if (slot.game && slot.progress !== 'Completed' && slot.permanentHandicaps.length < maxPermHandicapsForSlot) {
            const permPool = challengeData.permHandicaps[slot.game] || [];
            // Filter the pool to find handicaps not already active on this slot
            const availablePerms = permPool.filter(h => !slot.permanentHandicaps.includes(h));

            // If there are any available and unapplied handicaps, this slot is a truly eligible target
            if (availablePerms.length > 0) {
              trulyEligibleTargets.push({ slot, availablePerms });
            }
          }
        });

        if (trulyEligibleTargets.length > 0) {
          // Pick a random truly eligible target
          const randomTargetIndex = Math.floor(Math.random() * trulyEligibleTargets.length);
          const { slot: targetSlot, availablePerms } = trulyEligibleTargets[randomTargetIndex];

          // Pick a random available handicap for that target slot using weighted selection
          const newPermHandicap = getRandomWeightedHandicap(availablePerms);
          if (newPermHandicap) {
            targetSlot.permanentHandicaps.push(newPermHandicap);
            const fullHandicapText = newPermHandicap.name + (newPermHandicap.description ? ' - ' + newPermHandicap.description : '');
            addedPermHandicapMessage = `<br>New permanent handicap added to ${escapeHtml(targetSlot.game)}:<br><span class="${challengeData.rarityTiers[newPermHandicap.rarity]?.colorClass || ''}"><strong>${escapeHtml(fullHandicapText)} (${newPermHandicap.rarity})</strong></span>`;
          } else {
            addedPermHandicapMessage = `<br>No permanent handicaps available or all have zero weight for any eligible game.`;
          }
        } else {
          // This message only appears if NO slots are truly eligible across the entire rotation
          addedPermHandicapMessage = `<br>No active game slots could receive a new permanent handicap this rotation. All eligible games either have their maximum handicaps, or all available handicaps from their database pool are already active on them.`;
        }
      }

      // Stop timers
      challengeData.slots.forEach(s => { if (s.timerInterval) clearInterval(s.timerInterval); s.timerActive = false; });
      renderGames();
      updateTokenButton();

      let message = '';
      if (clearedAll) {
        message = 'All temporary handicaps cleared.<br>You got lucky and cleared all permanent handicaps too!';
      } else {
        message = 'All temporary handicaps have been cleared. Ready for next rotation!';
      }
      // Add automated handicap gains disabled message only if automated removals are NOT disabled and no perm handicap was added
      if (challengeData.disableAutomatedHandicapRemovals) {
        message += `<br>Automated permanent handicap removals are disabled in settings.`;
      }

      showResult('Rotation Complete', message + addedPermHandicapMessage);
    }

    function rollAchievement() {
      if (Math.random() < challengeData.tokenDropRate) {
        challengeData.tokens++;
        renderGames();
        updateTokenButton();
        showResult('Token Awarded!', `Congratulations! You earned a token by rolling an ${challengeData.achievementSystemName.toLowerCase()}.<br>You can use it to clear one permanent handicap (max once per rotation).`);
      } else {
        showResult(`No ${challengeData.achievementSystemName}`, `No ${challengeData.achievementSystemName.toLowerCase()} awarded this time. Keep going!`);
      }
    }

    function useToken() {
      if (challengeData.tokens <= 0) {
        showResult('No Tokens', "You don't have any tokens to use.");
        return;
      }
      if (challengeData.tokenUsedThisRotation) {
        showResult('Token Already Used', 'You can only use one token per rotation.');
        return;
      }
      const withPH = challengeData.slots.filter(s => s.permanentHandicaps.length > 0);
      if (withPH.length === 0) {
        showResult('No Handicaps', 'There are no permanent handicaps to clear.');
        return;
      }
      const slot = withPH[Math.floor(Math.random() * withPH.length)];
      const pick = slot.permanentHandicaps[Math.floor(Math.random() * slot.permanentHandicaps.length)];
      slot.permanentHandicaps = slot.permanentHandicaps.filter(h => h !== pick);
      challengeData.tokens--;
      challengeData.tokenUsedThisRotation = true;
      renderGames();
      updateTokenButton();
      const fullHandicapText = pick.name + (pick.description ? ' - ' + pick.description : '');
      showResult('Token Used', `Cleared a permanent handicap from ${escapeHtml(slot.game)}:<br><span class="${challengeData.rarityTiers[pick.rarity]?.colorClass || ''}"><strong>${escapeHtml(fullHandicapText)} (${pick.rarity})</strong></span>`);
    }

    // Timer
    function startTimer(slotId) {
      const slot = challengeData.slots.find(s => s.id === slotId);
      if (!slot || slot.timerActive) return;
      if (slot.timer <= 0) {
        showResult("Time's Up!", `Your 1-hour session for ${escapeHtml(slot.game || 'this slot')} has ended.`);
        return;
      }
      slot.timerActive = true;
      slot.timerInterval = setInterval(() => {
        slot.timer--; // Decrement timer
        if (slot.timer < 0) { // Check if timer has run out
          pauseTimer(slotId);
          showResult("Time's Up!", `Your 1-hour session for ${escapeHtml(slot.game || 'this slot')} has ended.`);
        }
        // Directly update the timer display for this slot
        const timerDisplayElement = document.querySelector(`#gameList > div[data-slot-id="${slot.id}"] .timer-display`);
        if (timerDisplayElement) {
          const timerMinutes = Math.floor(slot.timer / 60);
          const timerSeconds = slot.timer % 60;
          timerDisplayElement.textContent = `${timerMinutes.toString().padStart(2, '0')}:${timerSeconds.toString().padStart(2, '0')}`;
        }
        saveData();
      }, 1000);
      renderGames(); // Keep this to update button states etc.
    }

    function pauseTimer(slotId) {
      const slot = challengeData.slots.find(s => s.id === slotId);
      if (!slot || !slot.timerActive) return;
      slot.timerActive = false;
      clearInterval(slot.timerInterval);
      slot.timerInterval = null;
      // Directly update the timer display for this slot
      const timerDisplayElement = document.querySelector(`#gameList > div[data-slot-id="${slot.id}"] .timer-display`);
      if (timerDisplayElement) {
        const timerMinutes = Math.floor(slot.timer / 60);
        const timerSeconds = slot.timer % 60;
        timerDisplayElement.textContent = `${timerMinutes.toString().padStart(2, '0')}:${timerSeconds.toString().padStart(2, '0')}`;
      }
      renderGames(); // Keep this to update button states etc.
      saveData();
    }

    function resetTimer(slotId) {
      const slot = challengeData.slots.find(s => s.id === slotId);
      if (!slot) return;
      if (slot.timerInterval) clearInterval(slot.timerInterval);
      slot.timerActive = false;
      slot.timer = slot.sessionDuration; // Reset to custom duration
      slot.timerInterval = null;
      // Directly update the timer display for this slot immediately after reset
      const timerDisplayElement = document.querySelector(`#gameList > div[data-slot-id="${slot.id}"] .timer-display`);
      if (timerDisplayElement) {
        const timerMinutes = Math.floor(slot.timer / 60);
        const timerSeconds = slot.timer % 60;
        timerDisplayElement.textContent = `${timerMinutes.toString().padStart(2, '0')}:${timerSeconds.toString().padStart(2, '0')}`;
      }
      renderGames(); // Keep this to update button states etc.
      saveData();
    }

    function updateSessionDuration(slotId, durationMinutes) {
      const slot = challengeData.slots.find(s => s.id === slotId);
      if (slot) {
        const newDuration = parseInt(durationMinutes) * 60;
        if (!isNaN(newDuration) && newDuration > 0) {
          slot.sessionDuration = newDuration;
          // If timer is not active, reset it to the new duration
          if (!slot.timerActive) {
            slot.timer = newDuration;
            const timerDisplayElement = document.querySelector(`#gameList > div[data-slot-id="${slot.id}"] .timer-display`);
            if (timerDisplayElement) {
              const timerMinutes = Math.floor(slot.timer / 60);
              const timerSeconds = slot.timer % 60;
              timerDisplayElement.textContent = `${timerMinutes.toString().padStart(2, '0')}:${timerSeconds.toString().padStart(2, '0')}`;
            }
          }
          saveData();
        } else {
          slot.sessionDuration = 3600; // Default to 60 minutes if input is invalid or cleared
          if (!slot.timerActive) {
            slot.timer = 3600;
            const timerDisplayElement = document.querySelector(`#gameList > div[data-slot-id="${slot.id}"] .timer-display`);
            if (timerDisplayElement) {
              timerDisplayElement.textContent = `60:00`;
            }
          }
          saveData();
          // Optionally, visually reset the input field to 60
          document.getElementById(`duration-${slot.id}`).value = 60;
          alert('Invalid duration entered. Resetting to 60 minutes.');
        }
      }
    }

    // Database view
    function renderDatabase() {
      const dbList = document.getElementById('databaseList');
      dbList.innerHTML = '';

      // Get search input value
      const searchInput = document.getElementById('databaseSearchInput');
      const searchTerm = searchInput.value.toLowerCase();

      // Build sorted game list
      const games = [...challengeData.gameDatabase].sort((a,b) => a.localeCompare(b));

      // Filter games based on search term (contiguous substring match)
      const filteredGames = games.filter(game => {
        const lowerCaseGame = game.toLowerCase();

        // Create a regex for contiguous substring matching at word boundaries
        const regex = new RegExp(`\\b${searchTerm}`, 'i'); // '\\b' ensures word boundary

        if (searchTerm === '' || regex.test(lowerCaseGame)) return true; // Empty search term or regex match for game name

        // Check handicaps for contiguous substring match
        const permHandicaps = challengeData.permHandicaps[game] || [];
        const tempHandicaps = challengeData.tempHandicaps[game] || [];

        if (permHandicaps.some(h => regex.test(h))) return true;
        if (tempHandicaps.some(h => regex.test(h))) return true;

        return false;
      });

      if (filteredGames.length === 0) {
        dbList.innerHTML = `
          <div style="text-align: center; padding: 20px; border: 1px dashed #ddd; border-radius: 8px; background-color: #f9f9f9;">
            <p style="margin-bottom: 15px; color: #555;">No games found matching "<strong>${escapeHtml(searchInput.value)}</strong>".</p>
            <p style="font-size: 0.9em; color: #777; margin-bottom: 15px;">Adding a new game requires at least one handicap.</p>
            <button class="btn-primary" onclick="showAddHandicapModal('${escapeAttr(searchInput.value)}')">
              <i class="fas fa-plus"></i> Add "${escapeHtml(searchInput.value)}" as a new game
            </button>
          </div>
        `;
        return;
      }

      filteredGames.forEach(game => {
        const perm = challengeData.permHandicaps[game] || [];
        const temp = challengeData.tempHandicaps[game] || [];

        const el = document.createElement('div');
        el.className = 'database-game';
        el.innerHTML = `
          <div class="db-game-header">
            <h3 class="db-game-title">${escapeHtml(game)}</h3>
            <div class="db-game-actions">
              <button class="btn-primary btn-sm" onclick="showAddHandicapModal('${escapeAttr(game)}')"><i class="fas fa-plus"></i> Add Handicap</button>
              <button class="btn-warning btn-sm" onclick="showEditGameModal('${escapeAttr(game)}')"><i class="fas fa-edit"></i> Edit Game</button>
              <button class="btn-danger btn-sm" onclick="deleteGame('${escapeAttr(game)}')"><i class="fas fa-trash-alt"></i> Delete Game</button>
              <button class="btn-primary btn-sm" onclick="toggleHandicapList(this)"><i class="fas fa-minus"></i></button>
            </div>
          </div>
          <div class="db-game-settings" style="font-size: 0.9em; color: var(--gray); margin-bottom: 10px;">
            Max Perm. Handicaps: ${challengeData.gameSettings[game]?.maxPermHandicaps || 3}
          </div>
          <div class="handicap-list">
            <h4>Permanent Handicaps</h4>
            ${perm.length > 0
              ? perm.map(h => `
                  <div class="db-handicap permanent" data-game="${escapeAttr(game)}" data-type="permanent" data-handicap="${escapeAttr(h.name + (h.description ? ' - ' + h.description : ''))}">
                    <span class="${challengeData.rarityTiers[h.rarity]?.colorClass || ''}">${escapeHtml(h.name + (h.description ? ' - ' + h.description : ''))} (${h.rarity})</span>
                    <div class="handicap-actions">
                      <button class="handicap-btn" title="Edit" onclick="showEditHandicapModal('${escapeAttr(game)}', 'permanent', '${escapeAttr(h.name + (h.description ? ' - ' + h.description : ''))}')"><i class="fas fa-edit"></i></button>
                      <button class="handicap-btn" title="Delete" onclick="deleteHandicap('${escapeAttr(game)}', 'permanent', '${escapeAttr(h.name + (h.description ? ' - ' + h.description : ''))}')"><i class="fas fa-times"></i></button>
                    </div>
                  </div>`)
              .join('')
              : '<p>No permanent handicaps</p>'}
            <h4>Temporary Handicaps</h4>
            ${temp.length > 0
              ? temp.map(h => `
                  <div class="db-handicap temporary" data-game="${escapeAttr(game)}" data-type="temporary" data-handicap="${escapeAttr(h.name + (h.description ? ' - ' + h.description : ''))}">
                    <span class="${challengeData.rarityTiers[h.rarity]?.colorClass || ''}">${escapeHtml(h.name + (h.description ? ' - ' + h.description : ''))} (${h.rarity})</span>
                    <div class="handicap-actions">
                      <button class="handicap-btn" title="Edit" onclick="showEditHandicapModal('${escapeAttr(game)}', 'temporary', '${escapeAttr(h.name + (h.description ? ' - ' + h.description : ''))}')"><i class="fas fa-edit"></i></button>
                      <button class="handicap-btn" title="Delete" onclick="deleteHandicap('${escapeAttr(game)}', 'temporary', '${escapeAttr(h.name + (h.description ? ' - ' + h.description : ''))}')"><i class="fas fa-times"></i></button>
                    </div>
                  </div>`)
              .join('')
              : '<p>No temporary handicaps</p>'}
          </div>
        `;
        dbList.appendChild(el);
      });
    }

    function showAddHandicapModal(gameName = '') {
      const sel = document.getElementById('dbGameSelect');
      sel.innerHTML = '';
      const optNone = document.createElement('option');
      optNone.value = '';
      optNone.textContent = '-- Select existing game --';
      sel.appendChild(optNone);
      // sort for UX
      [...challengeData.gameDatabase].sort((a,b)=>a.localeCompare(b)).forEach(g => {
        const opt = document.createElement('option');
        opt.value = g;
        opt.textContent = g;
        sel.appendChild(opt);
      });
      document.getElementById('dbGameName').value = gameName || '';
      document.getElementById('handicapType').value = 'permanent';
      document.getElementById('handicapName').value = '';
      document.getElementById('handicapDescription').value = '';
      document.getElementById('bulkHandicaps').value = ''; // Clear bulk input
      document.getElementById('addHandicapModal').style.display = 'flex';
      // Conditionally show/hide maxPermHandicapsGroup
      const maxPermHandicapsGroup = document.getElementById('maxPermHandicapsGroup');
      if (maxPermHandicapsGroup) {
        maxPermHandicapsGroup.style.display = challengeData.customMaxPermHandicapsEnabled ? 'block' : 'none';
      }
      // Populate rarity dropdown
      const raritySelect = document.getElementById('handicapRarity');
      raritySelect.innerHTML = '';
      for (const rarity in challengeData.rarityTiers) {
        const option = document.createElement('option');
        option.value = rarity;
        option.textContent = rarity;
        raritySelect.appendChild(option);
      }
      raritySelect.value = 'Common'; // Default to Common
    }

    function addNewHandicap() {
      const gameSelect = document.getElementById('dbGameSelect').value.trim();
      const gameInput = document.getElementById('dbGameName').value.trim();
      const gameName = gameInput || gameSelect;
      const type = document.getElementById('handicapType').value;
      const name = document.getElementById('handicapName').value.trim();
      const description = document.getElementById('handicapDescription').value.trim();
      const maxPermHandicaps = parseInt(document.getElementById('maxPermHandicapsInput').value);
      const bulkInput = document.getElementById('bulkHandicaps').value.trim();
      const handicapsToAdd = bulkInput.split('\n').map(h => h.trim()).filter(h => h);
      const rarity = document.getElementById('handicapRarity').value; // Get selected rarity

      if (!gameName || !name) {
        alert('Please select or enter a game, and provide a handicap name.');
        return;
      }
      if (isNaN(maxPermHandicaps) || maxPermHandicaps < 1) {
        alert('Please enter a valid number (at least 1) for Max Permanent Handicaps.');
        return;
      }

      if (!challengeData.gameDatabase.includes(gameName)) {
        challengeData.gameDatabase.push(gameName);
      }
      if (!challengeData.permHandicaps[gameName]) challengeData.permHandicaps[gameName] = [];
      if (!challengeData.tempHandicaps[gameName]) challengeData.tempHandicaps[gameName] = [];
      // Initialize or update game settings
      if (!challengeData.gameSettings[gameName]) {
        challengeData.gameSettings[gameName] = { maxPermHandicaps: challengeData.customMaxPermHandicapsEnabled ? maxPermHandicaps : 3 };
      } else if (challengeData.gameSettings[gameName].maxPermHandicaps !== (challengeData.customMaxPermHandicapsEnabled ? maxPermHandicaps : 3)) {
        challengeData.gameSettings[gameName].maxPermHandicaps = challengeData.customMaxPermHandicapsEnabled ? maxPermHandicaps : 3;
      }

      const full = description ? `${name} - ${description}` : name;
      const handicapObject = { name: name, description: description, rarity: rarity };
      if (type === 'permanent') {
        challengeData.permHandicaps[gameName].push(handicapObject);
      } else {
        challengeData.tempHandicaps[gameName].push(handicapObject);
      }

      // Add bulk handicaps if any
      handicapsToAdd.forEach(h => {
        const [handicapName, handicapDesc] = h.split(' - ');
        const bulkHandicapObject = { name: handicapName, description: handicapDesc || '', rarity: rarity };
        if (type === 'permanent') {
          challengeData.permHandicaps[gameName].push(bulkHandicapObject);
        } else {
          challengeData.tempHandicaps[gameName].push(bulkHandicapObject);
        }
      });

      closeModal('addHandicapModal');
      renderDatabase();
      renderGames(); // updates dropdowns if new game
      saveData();
      showResult('Added to Database', `Added <strong>${escapeHtml(type)}</strong> handicap to <strong>${escapeHtml(gameName)}</strong>:<br><strong>${escapeHtml(full)}</strong>`);
    }

    function addBulkHandicaps() {
      const gameSelect = document.getElementById('dbGameSelect').value.trim();
      const gameInput = document.getElementById('dbGameName').value.trim();
      const gameName = gameInput || gameSelect;
      const type = document.getElementById('handicapType').value;
      const maxPermHandicaps = parseInt(document.getElementById('maxPermHandicapsInput').value);
      const bulkText = document.getElementById('bulkHandicaps').value.trim();
      const handicaps = bulkText.split('\n').map(h => h.trim()).filter(h => h); // Split by newline, trim whitespace, filter out empty lines
      const rarity = document.getElementById('handicapRarity').value; // Get selected rarity

      if (!gameName || handicaps.length === 0) {
        alert('Please select a game and enter at least one handicap.');
        return;
      }
      if (isNaN(maxPermHandicaps) || maxPermHandicaps < 1) {
        alert('Please enter a valid number (at least 1) for Max Permanent Handicaps.');
        return;
      }

      if (!challengeData.gameDatabase.includes(gameName)) {
        challengeData.gameDatabase.push(gameName);
      }
      if (!challengeData.permHandicaps[gameName]) challengeData.permHandicaps[gameName] = [];
      if (!challengeData.tempHandicaps[gameName]) challengeData.tempHandicaps[gameName] = [];
      // Initialize or update game settings
      if (!challengeData.gameSettings[gameName]) {
        challengeData.gameSettings[gameName] = { maxPermHandicaps: maxPermHandicaps };
      } else if (challengeData.gameSettings[gameName].maxPermHandicaps !== maxPermHandicaps) {
        challengeData.gameSettings[gameName].maxPermHandicaps = maxPermHandicaps;
      }

      const addedHandicaps = [];
      for (const h of handicaps) {
        const full = h; // No description for bulk add
        const handicapObject = { name: h.split(' - ')[0], description: h.split(' - ').length > 1 ? h.split(' - ').slice(1).join(' - ') : '', rarity: rarity };
        if (type === 'permanent') {
          // Check for duplicate handicap objects based on name and description (and rarity for strict uniqueness)
          if (!challengeData.permHandicaps[gameName].some(existing => existing.name === handicapObject.name && existing.description === handicapObject.description && existing.rarity === handicapObject.rarity)) {
            challengeData.permHandicaps[gameName].push(handicapObject);
            addedHandicaps.push(`<strong>${escapeHtml(full)}</strong>`);
          }
        } else {
          if (!challengeData.tempHandicaps[gameName].some(existing => existing.name === handicapObject.name && existing.description === handicapObject.description && existing.rarity === handicapObject.rarity)) {
            challengeData.tempHandicaps[gameName].push(handicapObject);
            addedHandicaps.push(`<strong>${escapeHtml(full)}</strong>`);
          }
        }
      }

      closeModal('addHandicapModal');
      renderDatabase();
      renderGames(); // updates dropdowns and slot handicaps
      saveData();
      showResult('Handicaps Added', `Added ${addedHandicaps.length} handicaps to <strong>${escapeHtml(gameName)}</strong>:<br>${addedHandicaps.join('<br>')}`);
    }

    // Edit Handicap
    function showEditHandicapModal(gameName, type, handicap) {
      // Store original values
      document.getElementById('originalEditGameName').value = gameName;
      document.getElementById('originalEditHandicapType').value = type;
      document.getElementById('originalEditHandicap').value = handicap;

      const sel = document.getElementById('editGameSelect');
      sel.innerHTML = '';
      const optNone = document.createElement('option');
      optNone.value = '';
      optNone.textContent = '-- Select existing game --';
      sel.appendChild(optNone);
      // sort for UX
      [...challengeData.gameDatabase].sort((a,b)=>a.localeCompare(b)).forEach(g => {
        const opt = document.createElement('option');
        opt.value = g;
        opt.textContent = g;
        sel.appendChild(opt);
      });
      document.getElementById('editGameSelect').value = gameName; // Select the current game
      document.getElementById('editGameName').value = gameName;
      document.getElementById('editHandicapType').value = type;
      const parts = handicap.split(' - ');
      document.getElementById('editHandicapName').value = parts[0];
      document.getElementById('editHandicapDescription').value = parts.length > 1 ? parts.slice(1).join(' - ') : '';
      document.getElementById('editHandicapModal').style.display = 'flex';

      // Populate rarity dropdown for edit modal
      const editRaritySelect = document.getElementById('editHandicapRarity');
      editRaritySelect.innerHTML = '';
      for (const r in challengeData.rarityTiers) {
        const option = document.createElement('option');
        option.value = r;
        option.textContent = r;
        editRaritySelect.appendChild(option);
      }
      // Find the handicap object to get its rarity
      const originalHandicapObject = (type === 'permanent' ? challengeData.permHandicaps[gameName] : challengeData.tempHandicaps[gameName])
                             .find(h => (h.name + (h.description ? ' - ' + h.description : '')) === handicap);
      if (originalHandicapObject) {
        editRaritySelect.value = originalHandicapObject.rarity;
        document.getElementById('originalEditHandicapRarity').value = originalHandicapObject.rarity;
      } else {
        editRaritySelect.value = 'Common'; // Default if not found or old format
        document.getElementById('originalEditHandicapRarity').value = 'Common';
      }
    }

    function saveEditedHandicap() {
      const originalGameName = document.getElementById('originalEditGameName').value;
      const originalHandicapType = document.getElementById('originalEditHandicapType').value;
      const originalHandicapString = document.getElementById('originalEditHandicap').value;
      const originalHandicapRarity = document.getElementById('originalEditHandicapRarity').value;

      const newGameSelect = document.getElementById('editGameSelect').value.trim();
      const newGameInput = document.getElementById('editGameName').value.trim();
      const newGameName = newGameInput || newGameSelect;
      const newHandicapType = document.getElementById('editHandicapType').value;
      const newHandicapName = document.getElementById('editHandicapName').value.trim();
      const newHandicapDescription = document.getElementById('editHandicapDescription').value.trim();
      const newHandicapRarity = document.getElementById('editHandicapRarity').value;

      if (!newGameName || !newHandicapName) {
        alert('Please select or enter a game, and provide a handicap name.');
        return;
      }

      const newFullHandicapString = newHandicapDescription ? `${newHandicapName} - ${newHandicapDescription}` : newHandicapName;
      const newHandicapObject = { name: newHandicapName, description: newHandicapDescription, rarity: newHandicapRarity };

      // Reconstruct original handicap object for filtering
      const originalHandicapParts = originalHandicapString.split(' - ');
      const originalHandicapObject = { name: originalHandicapParts[0], description: originalHandicapParts.length > 1 ? originalHandicapParts.slice(1).join(' - ') : '', rarity: originalHandicapRarity };

      // Remove old handicap using object comparison
      if (originalHandicapType === 'permanent') {
        challengeData.permHandicaps[originalGameName] = challengeData.permHandicaps[originalGameName].filter(h => 
          !(h.name === originalHandicapObject.name && h.description === originalHandicapObject.description && h.rarity === originalHandicapObject.rarity)
        );
      } else {
        challengeData.tempHandicaps[originalGameName] = challengeData.tempHandicaps[originalGameName].filter(h => 
          !(h.name === originalHandicapObject.name && h.description === originalHandicapObject.description && h.rarity === originalHandicapObject.rarity)
        );
      }

      // Add new game to database if it doesn't exist
      if (!challengeData.gameDatabase.includes(newGameName)) {
        challengeData.gameDatabase.push(newGameName);
      }
      if (!challengeData.permHandicaps[newGameName]) challengeData.permHandicaps[newGameName] = [];
      if (!challengeData.tempHandicaps[newGameName]) challengeData.tempHandicaps[newGameName] = [];

      // Add new handicap, avoiding duplicates in the new game's pool based on name, description, and rarity
      if (newHandicapType === 'permanent') {
        if (!challengeData.permHandicaps[newGameName].some(existing => 
          existing.name === newHandicapObject.name && existing.description === newHandicapObject.description && existing.rarity === newHandicapObject.rarity
        )) {
          challengeData.permHandicaps[newGameName].push(newHandicapObject);
        }
      } else {
        if (!challengeData.tempHandicaps[newGameName].some(existing => 
          existing.name === newHandicapObject.name && existing.description === newHandicapObject.description && existing.rarity === newHandicapObject.rarity
        )) {
          challengeData.tempHandicaps[newGameName].push(newHandicapObject);
        }
      }

      closeModal('editHandicapModal');
      renderDatabase();
      renderGames(); // updates dropdowns and slot handicaps
      saveData();
      showResult('Handicap Updated', `Updated <strong>${escapeHtml(newHandicapType)}</strong> handicap for <strong>${escapeHtml(newGameName)}</strong>:<br><strong>${escapeHtml(newFullHandicapString)}</strong>`);
    }

    // Delete Handicap
    function deleteHandicap(gameName, type, handicapString) {
      const confirm = window.confirm(`Are you sure you want to delete the "${escapeHtml(handicapString.split(' - ')[0])}" handicap from ${escapeHtml(gameName)}? This action cannot be undone.`);
      if (!confirm) return;

      // Find the handicap object to delete
      const handicapToDeleteName = handicapString.split(' - ')[0];
      const handicapToDeleteDescription = handicapString.split(' - ').length > 1 ? handicapString.split(' - ').slice(1).join(' - ') : '';

      // NOTE: We cannot rely on rarity for deletion here as we don't pass it from the UI call directly.
      // We'll filter based on name and description, which should be sufficiently unique for deletion.
      if (type === 'permanent') {
        challengeData.permHandicaps[gameName] = challengeData.permHandicaps[gameName].filter(h => !(h.name === handicapToDeleteName && h.description === handicapToDeleteDescription));
      } else {
        challengeData.tempHandicaps[gameName] = challengeData.tempHandicaps[gameName].filter(h => !(h.name === handicapToDeleteName && h.description === handicapToDeleteDescription));
      }

      // Also remove from any slots that might have this handicap
      challengeData.slots.forEach(slot => {
        if (slot.game === gameName) {
          if (type === 'permanent') {
            slot.permanentHandicaps = slot.permanentHandicaps.filter(h => !(h.name === handicapToDeleteName && h.description === handicapToDeleteDescription));
          } else {
            slot.temporaryHandicaps = slot.temporaryHandicaps.filter(h => !(h.name === handicapToDeleteName && h.description === handicapToDeleteDescription));
          }
        }
      });

      closeModal('editHandicapModal'); // Close edit modal if open
      renderDatabase();
      renderGames(); // updates dropdowns if new game
      saveData();
      showResult('Handicap Deleted', `Deleted <strong>${escapeHtml(type)}</strong> handicap from <strong>${escapeHtml(gameName)}</strong>:<br><strong>${escapeHtml(handicapString)}</strong>`);
    }

    // Reset progress (not database)
    function showResetModal() {
      document.getElementById('resetModal').style.display = 'flex';
    }

    function resetProgress() {
      const confirmTimerReset = window.confirm('Do you also want to reset all timers to their default 60-minute duration?');

      challengeData.slots.forEach(s => {
        s.progress = "Not Started";
        s.deaths = 0;
        s.permanentHandicaps = [];
        s.temporaryHandicaps = [];
        if (s.timerInterval) clearInterval(s.timerInterval);
        s.timerInterval = null;
        s.timerActive = false;
        if (confirmTimerReset) {
          s.timer = 3600; // Reset to 60 minutes
          s.sessionDuration = 3600; // Reset session duration as well
        } else {
          s.timer = s.sessionDuration; // Retain custom duration but reset timer to it
        }
      });
      challengeData.rotationsCompleted = 0;
      challengeData.tokens = 0;
      challengeData.tokenUsedThisRotation = false;

      closeModal('resetModal');
      renderGames();
      updateTokenButton();
      showResult('Progress Reset', 'All progress has been reset. Slots, selected games, and the database remain intact.');
    }

    // Function to clear total completed runs
    function clearTotalCompletedRuns() {
      const confirmClear = window.confirm('Are you sure you want to clear the Total Completed Runs counter? This cannot be undone.');
      if (confirmClear) {
        challengeData.totalCompletedRuns = 0;
        updateStats();
        saveData();
        showResult('Counter Cleared', 'Total Completed Runs counter has been reset to 0.');
      }
    }

    // Generic function to update settings
    function updateSetting(key, value) {
      challengeData[key] = value;
      saveData();
      renderSettings(); // Re-render settings to reflect potential changes (e.g., checkbox state)
      if (key === 'deathSystemName') {
        // If deathSystemName changes, update the stat item title
        document.getElementById('totalDeathsLabel').textContent = `${challengeData.deathSystemName}:`;
      }
    }

    // New function to handle toggle settings UI
    function toggleSettingUI(key) {
      challengeData[key] = !challengeData[key]; // Toggle the boolean value
      updateSetting(key, challengeData[key]); // Use existing updateSetting to save and re-render
    }

    // Render settings page
    function renderSettings() {
      document.getElementById('tokenDropRateInput').value = (challengeData.tokenDropRate * 100).toFixed(0);
      document.getElementById('permClearChanceInput').value = (challengeData.permClearChance * 100).toFixed(0);

      // Handle Manual Handicaps Toggle
      const manualHandicapsToggleContainer = document.getElementById('manualHandicapsToggleContainer');
      if (manualHandicapsToggleContainer) {
        if (challengeData.manualHandicapsEnabled) {
          manualHandicapsToggleContainer.classList.add('is-on');
          manualHandicapsToggleContainer.classList.remove('is-off');
          manualHandicapsToggleContainer.querySelector('.setting-toggle-indicator').textContent = 'ON';
        } else {
          manualHandicapsToggleContainer.classList.add('is-off');
          manualHandicapsToggleContainer.classList.remove('is-on');
          manualHandicapsToggleContainer.querySelector('.setting-toggle-indicator').textContent = 'OFF';
        }
      }
      
      document.getElementById('deathSystemNameInput').value = challengeData.deathSystemName;
      document.getElementById('achievementSystemNameInput').value = challengeData.achievementSystemName; // Populate new input

      // Handle Disable Automated Handicap Gains Toggle
      const disableAutomatedHandicapGainsToggleContainer = document.getElementById('disableAutomatedHandicapGainsToggleContainer');
      if (disableAutomatedHandicapGainsToggleContainer) {
        if (challengeData.disableAutomatedHandicapGains) {
          disableAutomatedHandicapGainsToggleContainer.classList.add('is-on');
          disableAutomatedHandicapGainsToggleContainer.classList.remove('is-off');
          disableAutomatedHandicapGainsToggleContainer.querySelector('.setting-toggle-indicator').textContent = 'ON';
        } else {
          disableAutomatedHandicapGainsToggleContainer.classList.add('is-off');
          disableAutomatedHandicapGainsToggleContainer.classList.remove('is-on');
          disableAutomatedHandicapGainsToggleContainer.querySelector('.setting-toggle-indicator').textContent = 'OFF';
        }
      }
      // Old checkbox removal
      // document.getElementById('disableAutomatedHandicapGainsToggle').checked = challengeData.disableAutomatedHandicapGains;

      // Handle Disable Automated Handicap Removals Toggle
      const disableAutomatedHandicapRemovalsToggleContainer = document.getElementById('disableAutomatedHandicapRemovalsToggleContainer');
      if (disableAutomatedHandicapRemovalsToggleContainer) {
        if (challengeData.disableAutomatedHandicapRemovals) {
          disableAutomatedHandicapRemovalsToggleContainer.classList.add('is-on');
          disableAutomatedHandicapRemovalsToggleContainer.classList.remove('is-off');
          disableAutomatedHandicapRemovalsToggleContainer.querySelector('.setting-toggle-indicator').textContent = 'ON';
        } else {
          disableAutomatedHandicapRemovalsToggleContainer.classList.add('is-off');
          disableAutomatedHandicapRemovalsToggleContainer.classList.remove('is-on');
          disableAutomatedHandicapRemovalsToggleContainer.querySelector('.setting-toggle-indicator').textContent = 'OFF';
        }
      }
      // Old checkbox removal
      // document.getElementById('disableAutomatedHandicapRemovalsToggle').checked = challengeData.disableAutomatedHandicapRemovals;

      // Handle Custom Max Permanent Handicaps Toggle
      const customMaxPermHandicapsToggleContainer = document.getElementById('customMaxPermHandicapsToggleContainer');
      if (customMaxPermHandicapsToggleContainer) {
        if (challengeData.customMaxPermHandicapsEnabled) {
          customMaxPermHandicapsToggleContainer.classList.add('is-on');
          customMaxPermHandicapsToggleContainer.classList.remove('is-off');
          customMaxPermHandicapsToggleContainer.querySelector('.setting-toggle-indicator').textContent = 'ON';
        } else {
          customMaxPermHandicapsToggleContainer.classList.add('is-off');
          customMaxPermHandicapsToggleContainer.classList.remove('is-on');
          customMaxPermHandicapsToggleContainer.querySelector('.setting-toggle-indicator').textContent = 'OFF';
        }
      }
      // Old checkbox removal
      // document.getElementById('customMaxPermHandicapsToggle').checked = challengeData.customMaxPermHandicapsEnabled;

      // Handle Dont Show Min Slot Warning Toggle
      const dontShowMinSlotWarningToggleContainer = document.getElementById('dontShowMinSlotWarningToggleContainer');
      if (dontShowMinSlotWarningToggleContainer) {
        if (challengeData.dontShowMinSlotWarning) {
          dontShowMinSlotWarningToggleContainer.classList.add('is-on');
          dontShowMinSlotWarningToggleContainer.classList.remove('is-off');
          dontShowMinSlotWarningToggleContainer.querySelector('.setting-toggle-indicator').textContent = 'ON';
        } else {
          dontShowMinSlotWarningToggleContainer.classList.add('is-off');
          dontShowMinSlotWarningToggleContainer.classList.remove('is-on');
          dontShowMinSlotWarningToggleContainer.querySelector('.setting-toggle-indicator').textContent = 'OFF';
        }
      }
      
      // Update rules tab achievement references
      const rulesAchievementsTitle = document.getElementById('rulesAchievementsTitle');
      if (rulesAchievementsTitle) rulesAchievementsTitle.textContent = challengeData.achievementSystemName + 's';

      const rulesAchievementText1 = document.getElementById('rulesAchievementText1');
      if (rulesAchievementText1) rulesAchievementText1.textContent = challengeData.achievementSystemName.toLowerCase();

      const settingsAchievementDropRateLabel = document.getElementById('settingsAchievementDropRateLabel');
      if (settingsAchievementDropRateLabel) settingsAchievementDropRateLabel.textContent = challengeData.achievementSystemName;

      const settingsAchievementHint1 = document.getElementById('settingsAchievementHint1');
      if (settingsAchievementHint1) {
        settingsAchievementHint1.innerHTML = `Every instance of "<strong>${challengeData.achievementSystemName.toLowerCase()}</strong>" has this chance to grant a token.`;
      }

      // Render Rarity Settings
      const raritySettingsContainer = document.getElementById('raritySettingsContainer');
      raritySettingsContainer.innerHTML = '';

      for (const rarityName in challengeData.rarityTiers) {
        const rarity = challengeData.rarityTiers[rarityName];
        const settingGroup = document.createElement('div');
        settingGroup.className = 'form-group';
        settingGroup.innerHTML = `
          <label for="rarityWeightInput-${rarityName}">${rarityName} Weight</label>
          <input type="number" id="rarityWeightInput-${rarityName}" min="0" step="0.1" value="${rarity.weight}" onchange="updateRarityWeight('${rarityName}', this.value)" />
          <p class="hint">Adjust the likelihood of ${rarityName} handicaps appearing. Higher value = more likely.</p>
        `;
        raritySettingsContainer.appendChild(settingGroup);
      }
    }

    function updateRarityWeight(rarityName, value) {
      const newWeight = parseFloat(value);
      if (!isNaN(newWeight) && newWeight >= 0) {
        challengeData.rarityTiers[rarityName].weight = newWeight;
        saveData();
        // No need to re-render settings completely, just save the change.
      } else {
        alert('Please enter a valid non-negative number for rarity weight.');
        // Revert the input field to its previous valid value
        document.getElementById(`rarityWeightInput-${rarityName}`).value = challengeData.rarityTiers[rarityName].weight;
      }
    }

    // Modular Rules Page Toggle
    function toggleRulesPageMode() {
      const rulesContent = document.getElementById('rulesContent');
      const settingsContent = document.getElementById('settingsContent');
      const rulesPageTitle = document.getElementById('rulesPageTitle');
      const toggleButtonText = document.getElementById('rulesPageToggleButtonText');
      const toggleButtonIcon = document.querySelector('#rules-tab .section-header button i');

      if (rulesContent.style.display !== 'none') {
        // Switch to settings view
        rulesContent.style.display = 'none';
        settingsContent.style.display = 'block';
        rulesPageTitle.textContent = 'Reroll Challenge Settings';
        toggleButtonText.textContent = 'Show Rules';
        toggleButtonIcon.classList.remove('fa-cog');
        toggleButtonIcon.classList.add('fa-book'); // Change icon to a book for rules
        renderSettings(); // Render settings when switching to settings view
      } else {
        // Switch back to rules view
        rulesContent.style.display = 'block';
        settingsContent.style.display = 'none';
        rulesPageTitle.textContent = 'Reroll Challenge rules';
        toggleButtonText.textContent = 'Show Settings';
        toggleButtonIcon.classList.remove('fa-book');
        toggleButtonIcon.classList.add('fa-cog'); // Change icon back to cog for settings
      }
    }

    // Game Edit/Delete
    function showEditGameModal(gameName) {
      document.getElementById('originalGameName').value = gameName;
      document.getElementById('editedGameName').value = gameName;
      // Set the max perm handicaps for the edited game
      const maxPermHandicaps = (challengeData.gameSettings[gameName] && challengeData.gameSettings[gameName].maxPermHandicaps !== undefined)
        ? challengeData.gameSettings[gameName].maxPermHandicaps
        : 3; // Default to 3 if not set
      document.getElementById('editedMaxPermHandicaps').value = maxPermHandicaps;

      document.getElementById('editGameModal').style.display = 'flex';

      // Conditionally show/hide maxPermHandicaps input
      const maxPermHandicapsEditGroup = document.querySelector('#editGameModal #editedMaxPermHandicaps').closest('.form-group');
      if (maxPermHandicapsEditGroup) {
        maxPermHandicapsEditGroup.style.display = challengeData.customMaxPermHandicapsEnabled ? 'block' : 'none';
      }
    }

    function saveEditedGame() {
      const originalGameName = document.getElementById('originalGameName').value;
      const newGameName = document.getElementById('editedGameName').value.trim();
      const newMaxPermHandicaps = parseInt(document.getElementById('editedMaxPermHandicaps').value);

      if (!newGameName) {
        alert('Game name cannot be empty.');
        return;
      }
      if (isNaN(newMaxPermHandicaps) || newMaxPermHandicaps < 1) {
        alert('Please enter a valid number (at least 1) for Max Permanent Handicaps.');
        return;
      }
      if (newGameName === originalGameName && newMaxPermHandicaps === (challengeData.gameSettings[originalGameName]?.maxPermHandicaps || 3)) {
        closeModal('editGameModal');
        return;
      }
      if (newGameName !== originalGameName && challengeData.gameDatabase.includes(newGameName)) {
        alert('A game with this name already exists.');
        return;
      }

      // Update game name in gameDatabase
      const index = challengeData.gameDatabase.indexOf(originalGameName);
      if (index > -1) {
        challengeData.gameDatabase[index] = newGameName;
      }

      // Update handicaps tied to the game
      challengeData.permHandicaps[newGameName] = challengeData.permHandicaps[originalGameName] || [];
      delete challengeData.permHandicaps[originalGameName];
      challengeData.tempHandicaps[newGameName] = challengeData.tempHandicaps[originalGameName] || [];
      delete challengeData.tempHandicaps[originalGameName];

      // Update game settings
      challengeData.gameSettings[newGameName] = {
        maxPermHandicaps: challengeData.customMaxPermHandicapsEnabled ? newMaxPermHandicaps : 3,
        ...(challengeData.gameSettings[originalGameName] ? { ...challengeData.gameSettings[originalGameName] } : {}),
      };
      // If game name changed, delete old settings
      if (newGameName !== originalGameName) {
        delete challengeData.gameSettings[originalGameName];
      }

      // Update slots that use this game
      challengeData.slots.forEach(slot => {
        if (slot.game === originalGameName) {
          slot.game = newGameName;
        }
      });

      closeModal('editGameModal');
      renderDatabase();
      renderGames(); // Update game dropdowns
      saveData();
      showResult('Game Renamed', `Game <strong>${escapeHtml(originalGameName)}</strong> renamed to <strong>${escapeHtml(newGameName)}</strong>.`);
    }

    function deleteGame(gameName) {
      const confirm = window.confirm(`Are you sure you want to delete the game "${escapeHtml(gameName)}" and all its associated handicaps? This action cannot be undone.`);
      if (!confirm) return;

      // Remove from gameDatabase
      challengeData.gameDatabase = challengeData.gameDatabase.filter(g => g !== gameName);

      // Remove handicaps
      delete challengeData.permHandicaps[gameName];
      delete challengeData.tempHandicaps[gameName];
      delete challengeData.gameSettings[gameName]; // Remove game settings

      // Clear game from any slots that use it
      challengeData.slots.forEach(slot => {
        if (slot.game === gameName) {
          slot.game = '';
          slot.permanentHandicaps = [];
          slot.temporaryHandicaps = [];
        }
      });

      renderDatabase();
      renderGames(); // Update dropdowns and slots
      saveData();
      showResult('Game Deleted', `Game <strong>${escapeHtml(gameName)}</strong> and all its handicaps have been deleted.`);
    }

    function toggleHandicapList(button) {
      const handicapList = button.closest('.database-game').querySelector('.handicap-list');
      if (handicapList) {
        handicapList.classList.toggle('hidden');
        const icon = button.querySelector('i');
        if (handicapList.classList.contains('hidden')) {
          icon.classList.remove('fa-minus');
          icon.classList.add('fa-plus');
        } else {
          icon.classList.remove('fa-plus');
          icon.classList.add('fa-minus');
        }
      }
    }

    // Export / Import
    function showExportModal() {
      const exportData = btoa(unescape(encodeURIComponent(JSON.stringify(challengeData))));
      document.getElementById('exportData').value = exportData;
      document.getElementById('exportModal').style.display = 'flex';
    }

    function copyExportData() {
      const ta = document.getElementById('exportData');
      ta.select();
      ta.setSelectionRange(0, 999999);
      document.execCommand('copy');
      showResult('Copied', 'Export seed copied to clipboard.');
    }

    function downloadSeedAsTxt() {
      const exportData = document.getElementById('exportData').value;
      const filename = `reroll_challenge_seed_${new Date().toISOString().slice(0, 10)}.txt`;
      const blob = new Blob([exportData], { type: 'text/plain;charset=utf-8' });
      const link = document.createElement('a');
      link.href = URL.createObjectURL(blob);
      link.download = filename;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(link.href);
      showResult('Downloaded', `Seed saved as ${filename}`);
    }

    function showImportModal() {
      document.getElementById('importData').value = '';
      document.getElementById('importFile').value = ''; // Clear file input
      document.getElementById('importModal').style.display = 'flex';
    }

    function importChallengeData(seedText = null) {
      const seed = seedText || document.getElementById('importData').value.trim();
      if (!seed) {
        alert('Please paste a seed or select a file to import.');
        return;
      }
      try {
        const decoded = JSON.parse(decodeURIComponent(escape(atob(seed))));
        // validate minimally
        if (!decoded || typeof decoded !== 'object' || !Array.isArray(decoded.slots)) throw new Error('Invalid seed');
        // stop timers
        if (challengeData.slots) {
          challengeData.slots.forEach(s => { if (s.timerInterval) clearInterval(s.timerInterval); });
        }
        challengeData = decoded;
        // sanitize timers
        challengeData.slots.forEach(s => { s.timerInterval = null; s.timerActive = false; s.timer = s.timer || 0; });

        closeModal('importModal');
        renderGames();
        renderDatabase();
        updateTokenButton();
        saveData();
        showResult('Data Imported', 'Your challenge data has been successfully imported.');
      } catch (e) {
        console.error('Import error', e);
        alert('Invalid seed. Please check your input and try again.');
      }
    }

    function importSeedFromFile() {
      const fileInput = document.getElementById('importFile');
      const file = fileInput.files[0];

      if (!file) {
        alert('Please select a .txt file to import.');
        return;
      }

      const reader = new FileReader();
      reader.onload = function(e) {
        try {
          const seedContent = e.target.result;
          importChallengeData(seedContent); // Pass content to existing import logic
        } catch (error) {
          console.error('Error reading file:', error);
          alert('Error reading file. Please ensure it is a valid .txt seed file.');
        }
      };
      reader.onerror = function() {
        alert('Failed to read file.');
      };
      reader.readAsText(file);
    }

    // Modals / UI helpers
    function showResult(title, content) {
      document.getElementById('resultTitle').textContent = title;
      document.getElementById('resultContent').innerHTML = content;
      document.getElementById('resultModal').style.display = 'flex';
    }

    function closeModal(id) {
      document.getElementById(id).style.display = 'none';
    }

    let resolveMinSlotWarningPromise = null; // To hold the resolve function of the promise

    function handleMinSlotWarningResponse(proceed) {
      if (resolveMinSlotWarningPromise) {
        resolveMinSlotWarningPromise(proceed);
        resolveMinSlotWarningPromise = null; // Reset
      }
    }

    function toggleDarkMode() {
      document.body.classList.toggle('dark-mode');
      challengeData.darkMode = document.body.classList.contains('dark-mode');
      saveData();
      const toggleBtn = document.querySelector('.dark-mode-toggle i');
      if (challengeData.darkMode) {
        toggleBtn.classList.remove('fa-moon');
        toggleBtn.classList.add('fa-sun');
      } else {
        toggleBtn.classList.remove('fa-sun');
        toggleBtn.classList.add('fa-moon');
      }
    }

    function escapeHtml(str) {
      return String(str)
        .replace(/&/g,'&amp;')
        .replace(/</g,'&lt;')
        .replace(/>/g,'&gt;')
        .replace(/"/g,'&quot;')
        .replace(/'/g,'&#39;');
    }
    function escapeAttr(str) {
      return String(str).replace(/'/g, '&#39;').replace(/"/g, '&quot;');
    }

    // Searchable Dropdown Logic
    function renderSearchableDropdown(inputElement, slotId) {
      const searchTerm = inputElement.value.toLowerCase();
      const resultsContainer = inputElement.nextElementSibling; // The div with class 'searchable-dropdown-results'
      const dropdownContainer = inputElement.closest('.searchable-dropdown');
      const gameCard = inputElement.closest('.game-card'); // Get the parent game-card

      resultsContainer.innerHTML = '';

      if (searchTerm === '') {
        // Show all games if search term is empty
        challengeData.gameDatabase.sort((a, b) => a.localeCompare(b)).forEach(game => {
          const item = document.createElement('div');
          item.className = 'searchable-dropdown-item';
          item.textContent = game;
          item.onmousedown = (e) => { // Use mousedown to prevent blur from firing before click
            e.preventDefault();
            inputElement.value = game;
            updateGame(slotId, game);
            resultsContainer.style.display = 'none';
            dropdownContainer.classList.remove('active');
            if (gameCard) gameCard.classList.remove('active-dropdown'); // Remove active class
          };
          resultsContainer.appendChild(item);
        });
      } else {
        // Filter games based on search term
        const regex = new RegExp(`\\b${searchTerm}`, 'i');
        challengeData.gameDatabase.filter(game => regex.test(game)).sort((a,b) => a.localeCompare(b)).forEach(game => {
          const item = document.createElement('div');
          item.className = 'searchable-dropdown-item';
          item.textContent = game;
          item.onmousedown = (e) => {
            e.preventDefault();
            inputElement.value = game;
            updateGame(slotId, game);
            resultsContainer.style.display = 'none';
            dropdownContainer.classList.remove('active');
            if (gameCard) gameCard.classList.remove('active-dropdown'); // Remove active class
          };
          resultsContainer.appendChild(item);
        });
      }

      resultsContainer.style.display = 'block';
      dropdownContainer.classList.add('active');
      if (gameCard) gameCard.classList.add('active-dropdown'); // Add active class to game card
    }

    function hideSearchableDropdown(inputElement) {
      const resultsContainer = inputElement.nextElementSibling;
      const dropdownContainer = inputElement.closest('.searchable-dropdown');
      const gameCard = inputElement.closest('.game-card'); // Get the parent game-card

      // Delay hiding to allow click on results item
      setTimeout(() => {
        if (!resultsContainer.contains(document.activeElement)) {
          resultsContainer.style.display = 'none';
          dropdownContainer.classList.remove('active');
          if (gameCard) gameCard.classList.remove('active-dropdown'); // Remove active class
        }
      }, 150);
    }

    // Manual Assign Handicap Functions
    function showManualAssignHandicapModal(slotId) {
      const slot = challengeData.slots.find(s => s.id === slotId);
      if (!slot || !slot.game) {
        showResult('No Game Selected', 'Please select a game for this slot before manually assigning handicaps.');
        return;
      }

      document.getElementById('manualAssignSlotId').value = slotId;
      document.getElementById('manualAssignGameName').value = slot.game;
      document.getElementById('manualAssignHandicapType').value = 'permanent'; // Default to permanent

      populateManualHandicaps(); // Populate dropdown based on initial type

      document.getElementById('manualAssignHandicapModal').style.display = 'flex';
    }

    function populateManualHandicaps() {
      const slotId = parseInt(document.getElementById('manualAssignSlotId').value);
      const slot = challengeData.slots.find(s => s.id === slotId);
      if (!slot) return;

      const gameName = slot.game;
      const type = document.getElementById('manualAssignHandicapType').value;
      const handicapSelect = document.getElementById('manualAssignHandicap');
      handicapSelect.innerHTML = '<option value="">-- Select a handicap --</option>';

      const pool = type === 'permanent' ? (challengeData.permHandicaps[gameName] || []) : (challengeData.tempHandicaps[gameName] || []);
      const currentHandicaps = type === 'permanent' ? slot.permanentHandicaps : slot.temporaryHandicaps;

      const availableHandicaps = pool.filter(h => !currentHandicaps.includes(h));

      availableHandicaps.forEach(h => {
        const option = document.createElement('option');
        option.value = h;
        option.textContent = h;
        handicapSelect.appendChild(option);
      });
    }

    function assignManualHandicap() {
      const slotId = parseInt(document.getElementById('manualAssignSlotId').value);
      const type = document.getElementById('manualAssignHandicapType').value;
      const selectedHandicap = document.getElementById('manualAssignHandicap').value;

      if (!selectedHandicap) {
        alert('Please select a handicap to assign.');
        return;
      }

      const slot = challengeData.slots.find(s => s.id === slotId);
      if (!slot) return;

      let targetHandicapArray;
      if (type === 'permanent') {
        targetHandicapArray = slot.permanentHandicaps;
      } else {
        targetHandicapArray = slot.temporaryHandicaps;
      }

      if (targetHandicapArray.includes(selectedHandicap)) {
        showResult('Handicap Already Assigned', `The ${type} handicap <strong>${escapeHtml(selectedHandicap)}</strong> is already assigned to ${escapeHtml(slot.game)}.`);
      } else {
        targetHandicapArray.push(selectedHandicap);
        showResult('Handicap Assigned', `Manually assigned ${type} handicap to ${escapeHtml(slot.game)}:<br><strong>${escapeHtml(selectedHandicap)}</strong>`);
      }

      closeModal('manualAssignHandicapModal');
      renderGames();
      saveData();
    }

    // Function to update max permanent handicaps from the slot view
    function updateSlotMaxPermHandicaps(slotId, value) {
      if (!challengeData.customMaxPermHandicapsEnabled) {
        alert('Custom Max Permanent Handicaps is disabled. Please enable it in Settings to use this feature.');
        // Revert the input value to the default or current saved value
        const slot = challengeData.slots.find(s => s.id === slotId);
        if (slot) {
          document.getElementById(`slotMaxPermHandicaps-${slotId}`).value = challengeData.gameSettings[slot.game]?.maxPermHandicaps || 3;
        }
        return;
      }
      const slot = challengeData.slots.find(s => s.id === slotId);
      if (!slot || !slot.game) return;

      const newMax = parseInt(value);
      if (isNaN(newMax) || newMax < 1) {
        alert('Please enter a valid number (at least 1) for Max Permanent Handicaps.');
        // Revert to old value if invalid
        document.getElementById(`slotMaxPermHandicaps-${slotId}`).value = challengeData.gameSettings[slot.game]?.maxPermHandicaps || 3;
        return;
      }

      if (!challengeData.gameSettings[slot.game]) {
        challengeData.gameSettings[slot.game] = {};
      }
      challengeData.gameSettings[slot.game].maxPermHandicaps = newMax;
      saveData();
      showResult('Settings Updated', `Max Permanent Handicaps for ${escapeHtml(slot.game)} set to ${newMax}.`);
      renderGames(); // Re-render to update any other UI elements that might depend on this setting
    }

    // Refresh UI function
    function refreshUI() {
      renderGames();
      updateStats();
      updateTokenButton();
      renderDatabase();
      renderSettings();
      showResult('UI Refreshed', 'All UI elements have been reloaded.');
    }

    // Notes Functions
    function saveNotes() {
      challengeData.challengeNotes = document.getElementById('challengeNotes').value;
      saveData();
      showResult('Notes Saved', 'Your challenge notes have been saved!');
    }

    function loadNotes() {
      document.getElementById('challengeNotes').value = challengeData.challengeNotes || '';
    }

    document.addEventListener('DOMContentLoaded', init);
  </script>
</body>
</html>

